<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on Evan Blog</title>
    <link>https://bytewalking.github.io/categories/tech/</link>
    <description>Recent content in Tech on Evan Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Jan 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://bytewalking.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>macOs Big Sur 根目录修改文件方法</title>
      <link>https://bytewalking.github.io/post/2021-01-03-mac-big-sur-root-modification/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2021-01-03-mac-big-sur-root-modification/</guid>
      <description>&lt;h2 id=&#34;step1-关闭系统保护sip&#34;&gt;step1: 关闭系统保护SIP&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;开机按住Commond+R，进入系统Recovery模式，在terminal中输入：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;csrutil authenticated-root disable；&#xA;csrutil disable&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果关闭authenticated-root失败，你需要将【文件保险箱】停用&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于Docker容器的算法模型部署</title>
      <link>https://bytewalking.github.io/post/2020-02-06-docker-and-model-deployment/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2020-02-06-docker-and-model-deployment/</guid>
      <description>&lt;h3 id=&#34;技术选型背景&#34;&gt;技术选型背景&lt;/h3&gt;&#xA;&lt;p&gt;模型开发是算法工程师的工作日常，模型算法的效果也决定着业务场景的上限，但是模型要发挥其作用，必须投入到实际生产场景，目前互联网环境下的生产场景主要是针对不同用户需求下的定制化业务服务，而模型要在业务场景下发挥它的价值就需要嵌入到业务服务当中，在这个过程中会面临以下几个问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>浅谈如何设计一个高并发系统</title>
      <link>https://bytewalking.github.io/post/2020-01-16-high-concurrency-system-design/</link>
      <pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2020-01-16-high-concurrency-system-design/</guid>
      <description>&lt;p&gt;从古至今，长江和黄河流域水患不断，远古时期大禹曾拓宽河道，清除淤沙让流水更加顺畅；都江堰作为史上最成功的的治水案例之一，用引流将岷江之水分流到多个支流中，以分担水流压力；三门峡和葛洲坝通过建造水库将水引入水库先存储起来，然后再想办法把水库中的水缓缓地排出去，以此提高下游的抗洪能力。而我们在应对高并发大流量时也会采用类似“抵御洪水”的方案，归纳起来共有三种方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>通过expalin可以得到什么？</title>
      <link>https://bytewalking.github.io/post/2019-08-02-mysql-explain-interpretation/</link>
      <pubDate>Sat, 03 Aug 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-08-02-mysql-explain-interpretation/</guid>
      <description>&lt;h2 id=&#34;通过expalin可以得到&#34;&gt;通过expalin可以得到&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;表的读取顺序&lt;/li&gt;&#xA;&lt;li&gt;表的读取操作的操作类型&lt;/li&gt;&#xA;&lt;li&gt;哪些索引可以使用&lt;/li&gt;&#xA;&lt;li&gt;哪些索引被实际使用&lt;/li&gt;&#xA;&lt;li&gt;表之间的引用&lt;/li&gt;&#xA;&lt;li&gt;每张表有多少行被优化器查询&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;如何调用expalin命令&#34;&gt;如何调用expalin命令&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;只需要在SELECT前面加上EXPLAIN即可，例如&lt;/p&gt;</description>
    </item>
    <item>
      <title>Guava Cache 用法指南</title>
      <link>https://bytewalking.github.io/post/2019-08-01-guava-cache-guide/</link>
      <pubDate>Thu, 01 Aug 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-08-01-guava-cache-guide/</guid>
      <description>&lt;p&gt;Guava Cache是在内存中缓存数据，相比较于数据库或redis存储，访问内存中的数据会更加高效。Guava官网介绍，下面的这几种情况可以考虑使用Guava Cache：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java 8 Iterable.forEach() vs foreach loop</title>
      <link>https://bytewalking.github.io/post/2019-07-31-java-8-foreach-vs-foreach-loop/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-07-31-java-8-foreach-vs-foreach-loop/</guid>
      <description>&lt;h1 id=&#34;java-8-iterableforeach-vs-foreach-loop&#34;&gt;Java 8 Iterable.forEach() vs foreach loop&lt;/h1&gt;&#xA;&lt;p&gt;Which of the following is better practice in Java 8?&lt;/p&gt;&#xA;&lt;p&gt;Java 8:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;joins.forEach(join -&amp;gt; mIrc.join(mSession, join));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Java 7:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;for (String join : joins) {&#xA;    mIrc.join(mSession, join);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;I have lots of for loops that could be &amp;ldquo;simplified&amp;rdquo; with lambdas, but is there really any advantage of using them? Would it improve their performance and readability?&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;I&amp;rsquo;ll also extend this question to longer methods. I know that you can&amp;rsquo;t return or break the parent function from a lambda and this should also be taken into consideration when comparing them, but is there anything else to be considered?&lt;/p&gt;</description>
    </item>
    <item>
      <title>RestFul API 知识总结</title>
      <link>https://bytewalking.github.io/post/2019-07-31-restful-api-essential-knowledge/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-07-31-restful-api-essential-knowledge/</guid>
      <description>&lt;h1 id=&#34;重要概念&#34;&gt;重要概念&lt;/h1&gt;&#xA;&lt;p&gt;REST,即Representational State Transfer的缩写，翻译过来就是&amp;quot;表现层状态转化&amp;quot;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;Resource&lt;/code&gt;（资源） ：对象的单个实例。例如，一只动物。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。&lt;/p&gt;</description>
    </item>
    <item>
      <title>技术例会会议记录</title>
      <link>https://bytewalking.github.io/post/2019-07-23-meeting-notes/</link>
      <pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-07-23-meeting-notes/</guid>
      <description>&lt;p&gt;我其实就是想水一篇，反正也没人看。公司给来我一个参加技术大佬们周例会的机会，做了一些笔记分享一下&lt;/p&gt;&#xA;&lt;h2 id=&#34;9pm项目周会笔记19722&#34;&gt;9PM项目周会笔记19/7/22&lt;/h2&gt;&#xA;&lt;h1 id=&#34;第一部分故障分析&#34;&gt;第一部分:故障分析&lt;/h1&gt;&#xA;&lt;p&gt;对Q2的故障数据进行分析和总结，数据来源CMDB，分成三个部分进行分析&lt;/p&gt;</description>
    </item>
    <item>
      <title>公平的洗牌算法</title>
      <link>https://bytewalking.github.io/post/2019-07-15-fair-shuffling-algorithm/</link>
      <pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-07-15-fair-shuffling-algorithm/</guid>
      <description>&lt;p&gt;曾经我问我的导师“如何才能把技术做深”，现在发现这个问题可能就是一个错误的问题。这种如何把技术做深的问题就好像是在问如何学好英语，如何成功。很多时候，面对很多问题，我们思考的方向，并非是怎么解决问题，而是，我们要解决的问题究竟是什么。&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务核心知识整理与归纳</title>
      <link>https://bytewalking.github.io/post/2019-07-10-micro-service-core-knowledge-collation-and-induction/</link>
      <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-07-10-micro-service-core-knowledge-collation-and-induction/</guid>
      <description>&lt;h2 id=&#34;hellomicroservices&#34;&gt;Hello，Microservices&lt;/h2&gt;&#xA;&lt;p&gt;本人初学微服务，此文章是对自己所学的内容进行整理和总结，部分图片和文字来源网络，侵删。&#xA;我对相关知识的理解还不是很到位，随着学习的深入，本文也会随时被更新，如有发现了错误还请指出，感谢。&lt;/p&gt;</description>
    </item>
    <item>
      <title>How To Build A Personal Blog Site</title>
      <link>https://bytewalking.github.io/post/2019-05-09-how-to-build-a-website-like-mine/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-05-09-how-to-build-a-website-like-mine/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/gohugoio/hugo#fetch-from-github&#34;&gt;Hugo&lt;/a&gt; is a static HTML and CSS website generator written in Go. It is optimized for speed, ease of use, and configurability. Hugo takes a directory with content and templates and renders them into a full HTML website.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-to-install&#34;&gt;How to Install&lt;/h2&gt;&#xA;&lt;h3 id=&#34;install-hugo-as-your-site-generator-binary-install&#34;&gt;Install Hugo as Your Site Generator (Binary Install)&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Homebrew (macOS)&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;brew install hugo&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;Chocolatey (Windows)&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;choco install hugo -confirm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Use the installation instructions in the &lt;a href=&#34;https://gohugo.io/getting-started/installing/&#34;&gt;Hugo documentation&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;build-and-install-the-binaries-from-source-advanced-install&#34;&gt;Build and Install the Binaries from Source (Advanced Install)&lt;/h3&gt;&#xA;&lt;p&gt;Prerequisite Tools:&lt;/p&gt;</description>
    </item>
    <item>
      <title>How To Build A Personal Blog Site(中文版)</title>
      <link>https://bytewalking.github.io/post/2019-05-09-how-to-build-a-website-like-mine-chinese/</link>
      <pubDate>Thu, 09 May 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-05-09-how-to-build-a-website-like-mine-chinese/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/gohugoio/hugo#fetch-from-github&#34;&gt;Hugo&lt;/a&gt; 是一款使用Go语言编写的静态语言生成器。它对构建速度，易用性和可配置性等方面进行了优化。Hugo的目录内包含content和templates等部分，并将它们打包呈现为一个完整的HTML网站&lt;/p&gt;</description>
    </item>
    <item>
      <title>单点登录的原理和实现</title>
      <link>https://bytewalking.github.io/post/2019-05-08-single-sign-on-design-and-implementation/</link>
      <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/post/2019-05-08-single-sign-on-design-and-implementation/</guid>
      <description>&lt;h1 id=&#34;单系统登录机制&#34;&gt;单系统登录机制&lt;/h1&gt;&#xA;&lt;h2 id=&#34;http无状态协议&#34;&gt;http无状态协议&lt;/h2&gt;&#xA;&lt;p&gt;Web应用一般都是采用browser/server架构，使用http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器都会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务安全沉思录之三</title>
      <link>https://bytewalking.github.io/2018/05/23/external_system_auth/</link>
      <pubDate>Wed, 23 May 2018 18:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/2018/05/23/external_system_auth/</guid>
      <description>&lt;h2 id=&#34;外部系统访问控制&#34;&gt;外部系统访问控制&lt;/h2&gt;&#xA;&lt;p&gt;除用户访问和微服务之间的相互访问外，外部的第三方系统也可能需要访问系统内部的微服务。例如在上一篇博客的网上商店例子中，外部的推荐服务可能需要接入系统，以获取商店的商品目录信息。相对于内部服务之间的访问而言，外部系统的访问需要进行严格的安全控制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务安全沉思录之二</title>
      <link>https://bytewalking.github.io/2018/05/23/service_2_service_auth/</link>
      <pubDate>Wed, 23 May 2018 15:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/2018/05/23/service_2_service_auth/</guid>
      <description>&lt;h2 id=&#34;服务间认证与鉴权&#34;&gt;服务间认证与鉴权&lt;/h2&gt;&#xA;&lt;p&gt;除来自用户的访问请求以外，微服务应用中的各个微服务相互之间还有大量的访问，包括下述场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用户间接触发的微服务之间的相互访问&lt;BR&gt;&#xA;例如在一个网上商店应用中，用户访问购物车微服务进行结算时，购物车微服务可能需要访问用户评级微服务获取用户的会员级别，以得到用户可以享受购物折扣。&lt;/li&gt;&#xA;&lt;li&gt;非用户触发的微服务之间的相互访问&lt;BR&gt;&#xA;例如数据同步或者后台定时任务导致的微服务之间的相互访问。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;根据应用系统的数据敏感程度的不同，对于系统内微服务的相互访问可能有不同的安全要求。&lt;/p&gt;</description>
    </item>
    <item>
      <title>微服务安全沉思录之一</title>
      <link>https://bytewalking.github.io/2018/05/22/user_authentication_authorization/</link>
      <pubDate>Wed, 23 May 2018 10:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/2018/05/22/user_authentication_authorization/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;这段时间对之前微服务安全相关的一些想法进行了进一步总结和归纳，理清了在之前文章里面没有想得太清楚的地方，例如服务间的认证与鉴权以及用户身份在服务调用链中的传递。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Istio Sidecar自动注入原理</title>
      <link>https://bytewalking.github.io/2018/05/23/istio-auto-injection-with-webhook/</link>
      <pubDate>Wed, 23 May 2018 00:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/2018/05/23/istio-auto-injection-with-webhook/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Kubernets 1.9版本引入了Admission Webhook(web 回调)扩展机制，通过Webhook,开发者可以非常灵活地对Kubernets API Server的功能进行扩展，在API Server创建资源时对资源进行验证或者修改。&lt;/p&gt;&#xA;&lt;p&gt;使用webhook的优势是不需要对API Server的源码进行修改和重新编译就可以扩展其功能。插入的逻辑实现为一个独立的web进程，通过参数方式传入到kubernets中，由kubernets在进行自身逻辑处理时对扩展逻辑进行回调。&lt;/p&gt;&#xA;&lt;p&gt;Istio 0.7版本就利用了Kubernets webhook实现了sidecar的自动注入。&lt;/p&gt;</description>
    </item>
    <item>
      <title>谈谈微服务架构中的基础设施：Service Mesh与Istio</title>
      <link>https://bytewalking.github.io/2018/03/29/what-is-service-mesh-and-istio/</link>
      <pubDate>Thu, 29 Mar 2018 12:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/2018/03/29/what-is-service-mesh-and-istio/</guid>
      <description>&lt;h2 id=&#34;微服务架构的演进&#34;&gt;微服务架构的演进&lt;/h2&gt;&#xA;&lt;p&gt;作为一种架构模式，微服务将复杂系统切分为数十乃至上百个小服务，每个服务负责实现一个独立的业务逻辑。这些小服务易于被小型的软件工程师团队所理解和修改，并带来了语言和框架选择灵活性，缩短应用开发上线时间，可根据不同的工作负载和资源要求对服务进行独立缩扩容等优势。&lt;/p&gt;&#xA;&lt;p&gt;另一方面，当应用被拆分为多个微服务进程后，进程内的方法调用变成了了进程间的远程调用。引入了对大量服务的连接、管理和监控的复杂性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何构建安全的微服务应用？</title>
      <link>https://bytewalking.github.io/2018/05/22/user_authentication_authorization/</link>
      <pubDate>Sat, 03 Feb 2018 12:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/2018/05/22/user_authentication_authorization/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;微服务架构的引入为软件应用带来了诸多好处：包括小开发团队，缩短开发周期，语言选择灵活性，增强服务伸缩能力等。与此同时，也引入了分布式系统的诸多复杂问题。其中一个挑战就是如何在微服务架构中实现一个灵活，安全，高效的认证和鉴权方案。本文将尝试就此问题进行一次比较完整的探讨。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何从外部访问Kubernetes集群中的应用？</title>
      <link>https://bytewalking.github.io/2017/11/28/access-application-from-outside/</link>
      <pubDate>Tue, 28 Nov 2017 12:00:00 +0000</pubDate>
      <guid>https://bytewalking.github.io/2017/11/28/access-application-from-outside/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;我们知道，kubernetes的Cluster Network属于私有网络，只能在cluster Network内部才能访问部署的应用，那如何才能将Kubernetes集群中的应用暴露到外部网络，为外部用户提供服务呢？本文探讨了从外部网络访问kubernetes cluster中应用的几种实现方式。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
