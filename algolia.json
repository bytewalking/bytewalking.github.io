[{"author":null,"categories":["Life"],"content":"我一直在思考，在社会宏大叙事下，科技进步是否真的能提升人们的生活质量？比如，无人驾驶汽车一旦普及，意味着滴滴司机可能会失业。\n从历史来看，每一次技术革命或社会制度变革，都会让许多人沦为社会进步的牺牲品。这段历史，我也深有体会。爸爸年轻时曾在国有葡萄酒厂工作，改革开放期间，他就成为了下岗工人。因此，我时常焦虑：是否有一天，我也会成为这个系统更迭的牺牲品。\n但从另一面看，现在我每月只需花二十美元，就能让苏格拉底、叔本华24小时不间断地陪伴我、与我对话——在古代，这种待遇只有帝王和贵族才能拥有。科技进步，确实是一份复杂的恩赐。它迫使我们不断升级认知，理解社会结构和逻辑，选择合适的入口，重新定义“有意义的生活与工作”。也许，正是这种不确定感，让这场生存游戏充满了趣味与挑战。\n回忆童年，为了让我接受更好的教育，爸妈千方百计把我送进了宿迁最好的小学。那里的大多数孩子出身显赫，而我的家庭背景显得格格不入，也因此不可避免地受到一些不公正的对待。比如，当我和某同学起冲突时，老师往往讨好部分学生家长，而对我颐指气使，把责任全部推给我。也正因此，我从小学会了察言观色，但同时陷入自卑，开始怀疑自身价值。我不确定，这是否就是我心理敏感的根源，但从小我就对公正与秩序有着强烈的渴望。\n当然，爸妈已经尽力了，他们拼尽全力生活着，不应苛求更多。只是当年他们以为“上好学校就够了”，却未曾意识到我在其中经历的孤独与压抑。直到大学，我才逐渐挣脱旧有标签，真正开始构建自我，在新的城市重新生活。也正因如此，毕业后我选择留在外地，不愿回老家。不是逃避，而是想重新定义自己的人生节奏。\n那么——一个人究竟该如何从“别人眼中的自己”，转变为“自己认同的自己”呢？\n","date":1747008000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":800,"html":"我在思考在社会宏大叙述下，科技进步是不是真的会提升人们的生活质量？比如无人驾驶汽车进入市场后就意味着滴滴司机会被淘汰。","keywords":null,"kind":"page","lang":"en","lastmod":1747008000,"objectID":"27a62ba23bc822197fc5efcb324d5747","permalink":"https://bytewalking.github.io/post/2025-05-12-out-of-the-labels-we-emerge/","publishdate":"2025-05-12T00:00:00Z","readingtime":2,"relpermalink":"/post/2025-05-12-out-of-the-labels-we-emerge/","section":"post","tags":["think"],"title":"从标签中走出的我们","type":"post","url":"/post/2025-05-12-out-of-the-labels-we-emerge/","weight":0,"wordcount":712},{"author":null,"categories":["Life"],"content":"揭开幕布的一束光 最近在酝酿一个想法：如果我将自己的想法和周记写成文章，发到朋友圈的流量池中，会对我产生什么样的影响？\n这对我来说是一件非常困难，也非常需要勇气的事情。还没开始做之前，我已经预想到真诚的自我袒露可能带来的种种风险。也许会看到熟人的沉默或冷淡的回应，也可能会被误解，把脆弱当成软弱，或者从我的文字缝隙中寻找攻击点。或许这些内容本该留给深夜，或留给知己，甚至没人真正关心你在想什么。但我知道，真诚既是一把刀子，也是一枚钥匙。我把这些文字写出来，也许会发出，也许不会——但这是自我叙述中最重要的一步：**先写下来。**那写出来，对我到底有什么好处呢？\n我想要撕掉标签，重新定义自己。大多数时候，我是通过他者的视角来看自己，而自我叙述的过程，正是和这种外部视角进行校准的一种方式，让我尽可能看清楚“我是谁”。所以这个过程，并不是写给朋友圈里的“各位”看的，而是写给我自己。在他者视角中，我是不善言辞、内向的人。但事实并非如此。通过这半年不断写周记、与亲密的人进行深度交流，在 AI 的启发下，我意识到：我是一个情感细腻的人，只是不擅长用非结构化的方式表达自己。而现在，我找到了自己舒服的表达路径——使用带有结构感和思考密度的文字，去建立我与世界的连接。我希望被理解，但我不希望被定义。\n同时，我也想重塑他者的视角。不是你告诉我我是怎样的人，而是我主动告诉你：我是谁。如果你愿意了解我，请从这里开始。写下这些文字，也是我的一种自我认证。我曾经走到了这里，并在此留下痕迹。它不是人设，不是矫情，只是一次安静的自我表达。如果你觉得无法认同或不感兴趣，也没关系，可以默默屏蔽我，这并不影响什么。\n我之所以有了分享的念头，也受到我大学时计算机老师徐教授的启发。他经常在朋友圈分享自己曾在非洲教学的经历，我不仅看得津津有味，也因此在有限的接触中，对他产生了一种真实的人与人的连接。我也可以坦然承认：我很多想法并不是原创的。我在不断模仿——加缪、王小波、一些博主，甚至包括 GPT 和朋友圈的各位都是我的叙述盟友。他们的思考和表达不断影响我。但我不会全盘照搬，只有当我将这些思想整合、内化、反复咀嚼后再写出来，它才成为我认可的、属于我的一部分。\n下面说说，他者已经给我贴上的标签：\n程序员、内向、温柔、文艺、脾气好、老实、不爱说话。\n这符合你们对我的刻板印象吗？如果是，那很遗憾，你并不了解我。不过这也没关 …","date":1746835200,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1400,"html":"最近在酝酿一个想法：如果我将自己的想法和周记写成文章，发到朋友圈的流量池中，会对我产生什么样的影响？","keywords":null,"kind":"page","lang":"en","lastmod":1746835200,"objectID":"fe3a9e3f8c73b97f33ddfe9320a82537","permalink":"https://bytewalking.github.io/post/2025-05-10-self-exposure-social-experiment/","publishdate":"2025-05-10T00:00:00Z","readingtime":3,"relpermalink":"/post/2025-05-10-self-exposure-social-experiment/","section":"post","tags":["think"],"title":"一次自我暴露的社会实验","type":"post","url":"/post/2025-05-10-self-exposure-social-experiment/","weight":0,"wordcount":1385},{"author":null,"categories":["Life"],"content":"城市的一双眼睛 假期的第一站，是去找凯辉借相机。他现在在一家叫 Recreate Games 的游戏公司工作，公司成名作是《猛兽派对》，他们的游戏发售爆火后就搬了办公地点。办公室位于五角场附近的高层写字楼，透过落地窗能看到浦东三件套与东方明珠构成的上海天际线，仿佛城市在努力告诉你它的宏大和忙碌。凯辉说每个站到窗边的人都会忍不住拍一张，我也不例外的掏出了手机。仔细观察他的工位，比我稍微“丰富”一些，一张富士山的缩放照片被放在一个袖珍相框内，还有一张他与富士山的合影照摆在另一侧。还有一些他们公司周边立牌之类的装饰随意摆放着。能从办公室看到城市天际线，是否就意味着已经成功了。\n与心动一样每个人都配置了升降桌，但桌与桌的间距很大，没有那种格子间的压抑感。凯辉很骄傲的介绍他们的老板多么一丝不苟，连工位摆放角度都是拿激光仪对齐过的。确实名不虚传，早就听说《猛兽派对》的老板对细节要求非常高，细节到不同角色使用不同道具拖在地上发出的声音都不同。他们的游戏确实算成功了，以195万份销量、3.6亿元的销售额位居23年国产游戏销量榜（steam \u0026amp;amp; xbox）第一。这种似曾相识的感觉让我有点怀念在心动的工作经历了，对于告别我总是不舍，但是在高压环境下的挣扎只有身处其中的自己才能感受到，就如《人生切割术》中的 Mark 一样。\n凯辉递来一台 Yashica Electro 35 胶片相机。我接过时有点小心翼翼，这种金属机身带来的重量感和智能手机那种“轻浮感”完全不一样。相机不止是看起来复古，使用方式也想当复古。每拍完一张照片就需要拨动转轴切换胶片。拍照的仪式感非常足，你要从取景窗内思考构图，转动镜头对焦，控制按下快门的速度，每次拍照都会有创作艺术的感觉。相机使用的胶卷一卷只有 36 张，每一张都得慎重。或许生活也是如此，只是我们总会忘了按快门的代价。多一些敬畏之心不是坏事对吧。\n旧书店的一页纸刺进了内心 下午去附近的大学城吃饭，碰巧发现复旦旧书店就在附近，遂去参观一下。书店的样貌和我想象的一样，一堆旧书毫无规律随意的堆砌着，我也没有目的的在里面挖宝，妄图找到点意外收获。\n偶然翻到一本老书：《一个女大学生的手记》。泛黄的封面上印着抽象的插图，一位女孩站在橙色的地面上，背景是昏黄的太阳和飞鸟，像在表达一个有关“独处与自由”的比喻。随手翻到一页便停了下来：\n几个复旦中文系男人讨论自己的爱 …","date":1746403200,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2500,"html":"夜色正浓，心绪也轻轻飘了起来。最近项目终于上线，我得以短暂喘息，摸鱼的时间悄悄多了起来。","keywords":null,"kind":"page","lang":"en","lastmod":1746403200,"objectID":"d65d8b77c53cc6598a8cdff7f2a24142","permalink":"https://bytewalking.github.io/post/2025-05-05-life-on-hold/","publishdate":"2025-05-05T00:00:00Z","readingtime":5,"relpermalink":"/post/2025-05-05-life-on-hold/","section":"post","tags":["think"],"title":"试着让生活暂停一下","type":"post","url":"/post/2025-05-05-life-on-hold/","weight":0,"wordcount":2474},{"author":null,"categories":["Life"],"content":"Slacking Log #1\n夜色正浓，心绪也轻轻飘了起来。最近项目终于上线，我终于能短暂喘息，摸鱼的时间悄悄多了起来。年前，一位同事提议让我帮他做一个量化交易的小工具。借助AI的力量，我们很快搭建起了一个简易的量化交易与回测系统。虽然这个项目与我的本职工作毫无关系，但我并不觉得自己在偷懒。相反，它像是在流水线的间隙中挣脱出来，为自己开辟了一片自由呼吸、自由探索的空间。\n每天有太多时间被通勤和琐碎事务吞噬，久而久之，我开始反思：那些所谓的“工作成果”，真的能带来价值感与归属感吗？说来也许有些可笑，我的工作效率其实并不算高。总忍不住反复琢磨，寻找更优的解法，哪怕是一行代码、一个细节，也愿意反复推敲、重构。这或许与老板的期待背道而驰，但大多数时候，我还是执拗地坚持着。\n下面这张是程序运行时的效果图。（80%的代码，其实都是GPT写的。我更像一位导演，指引它讲好每一个小故事，纠正细节上的偏差。）最终，这个小系统只需输入一支股票代码和时间区间，就能基于历史数据推算出最佳买卖时点，并自动计算收益。当然，这只是一个demo，属于玩具性质。真要落地，还得面对券商严苛的自动交易准入门槛——这门槛，现在的我们还负担不起。但它是我第一次通过GPT完整做出的项目，也让我隐隐意识到：未来的生产方式，正在悄悄改变。\n做这个项目的时候，我想起了《星际迷航：下层舰员》里的一个情节。某天，舰长为了提升效率，下令每一项任务都设定倒计时，一项完成，立刻分配下一项——不给任何人喘息的机会。表面上，效率猛增，每个人似乎都在“高效运转”，但真正的灾难也在悄悄酝酿。直到某次敌袭，本应迅速反应的船员们却因被任务死死捆住，无人能腾出手来应对。飞船仿佛一台疯狂自转的机器，只能眼睁睁看着敌人入侵。讽刺的是，唯一一个从不偷懒、最循规蹈矩的Boimler，反倒成了拯救危机的关键。他建议舰长设立“自由创造时间”，让船员们拥有喘息和自主判断的余地。最终，这项建议扭转了局势，却被历史讽刺性地记录为“星际联邦史上最懒惰的人”。这个故事让我想了很久：所谓的“高效”，未必是堆砌出来的执行力，而是要给创造力留出一片自由呼吸的空间。那一小块自由，也许才是系统真正的安全阀。\n这些天，AI也在悄悄改变着我的生活。最初，它只是个更好用的搜索引擎；后来，它开始帮我分析代码结构、查日志异常、生成Git commit message，节省了不少琐 …","date":1745366400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1700,"html":"夜色正浓，心绪也轻轻飘了起来。最近项目终于上线，我得以短暂喘息，摸鱼的时间悄悄多了起来。","keywords":null,"kind":"page","lang":"en","lastmod":1745366400,"objectID":"88dfb2fb522e870ea00894312f0300fe","permalink":"https://bytewalking.github.io/post/2025-04-23-first-day-of-slacking-off/","publishdate":"2025-04-23T00:00:00Z","readingtime":4,"relpermalink":"/post/2025-04-23-first-day-of-slacking-off/","section":"post","tags":["think"],"title":"摸鱼日志第一篇","type":"post","url":"/post/2025-04-23-first-day-of-slacking-off/","weight":0,"wordcount":1655},{"author":null,"categories":["Tech"],"content":"step1: 关闭系统保护SIP 开机按住Commond+R，进入系统Recovery模式，在terminal中输入： csrutil authenticated-root disable； csrutil disable 如果关闭authenticated-root失败，你需要将【文件保险箱】停用\n然后重启系统\nstep2: 重新将系统盘挂载到本地 在任意地方新建的目录，例如 /Users/name/Desktop/temp\n使用命令sudo mount -o nobrowse -t apfs /dev/diskNsM /xxx/xx 重新将系统盘挂载到本地 注意：diskNsM 为系统盘的设备名，这个在\u0026amp;quot;磁盘工具-设备\u0026amp;quot; 里可以看到（例如：disk1s5s1），注意要把后面的s1去掉，因为磁盘工具里面里显示的是系统盘的快照，挂载成这个snapshot是没用的！\n按上述描述，我们应该执行的命令是：\nsudo mount -o nobrowse -t apfs /dev/disk1s5 /Users/name/Desktop/temp step3: 修改文件 经过step2的操作，系统盘就重新挂载到了桌面的temp文件夹下面，从这个文件夹进去就是系统根目录了。而且这个文件夹是可读可写的，我们把要修改的系统配置文件夹/文件 复制到相应的系统目录里\n我的需求只是在根目录下软链一个文件夹，所以在temp文件夹下，我只需执行以下命令\nsudo Ln -s /Users/name/Workspace/ServiceLog/data0 step4: 重建系统 snapshot 使用到的命令为sudo bless --folder /xxx/xx/System/Library/CoreServices --bootefi --create-snapshot，其中/xxx/xx是最初设置的目录\n如果是上述例子，我们需要执行\nsudo bless --folder /Users/name/Desktop/temp/System/Library/CoreServices --bootefi --create-snapshot 重启系统，会发现挂载的磁盘消失，而修改的设置已经写入到原先不能更改的系统文件中了 step5: 重新开启SIP 重新进入Recovery模式， …","date":1609718400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":700,"html":"这是一份记录如何在 macOS 上暂时解除系统保护、挂载系统盘、修改底层文件并重新创建快照的完整流程。它适用于那些需要动刀子改系统、却又希望在操作后恢复安全性的开发者。","keywords":null,"kind":"page","lang":"en","lastmod":1609718400,"objectID":"a311420345782a04987afe0472942928","permalink":"https://bytewalking.github.io/post/2021-01-03-mac-big-sur-root-modification/","publishdate":"2021-01-04T00:00:00Z","readingtime":2,"relpermalink":"/post/2021-01-03-mac-big-sur-root-modification/","section":"post","tags":["mac"],"title":"macOs Big Sur 根目录修改文件方法","type":"post","url":"/post/2021-01-03-mac-big-sur-root-modification/","weight":0,"wordcount":610},{"author":null,"categories":["Tech"],"content":"技术选型背景 模型开发是算法工程师的工作日常，模型算法的效果也决定着业务场景的上限，但是模型要发挥其作用，必须投入到实际生产场景，目前互联网环境下的生产场景主要是针对不同用户需求下的定制化业务服务，而模型要在业务场景下发挥它的价值就需要嵌入到业务服务当中，在这个过程中会面临以下几个问题：\n模型服务不同于常规的业务服务，常规业务服务的技术瓶颈在处理高并发请求和复杂的业务逻辑，而模型服务的技术瓶颈在CPU密集型计算和预测响应上，所以在请求密集的情况下模型服务会更占用CPU，同时在一次模型预估的时间也会高于常规业务服务的请求逻辑。 算法工程师和研发工程师之间的技术栈不同，算法工程师大部分使用python进行特征工程，模型开发，研发工程师更多使用C++，java，Go这种工程能力更健壮的编程语言，因此模型在部署时面临着技术栈上的交流成本。 模型是基于数据开发的，所以模型具有一定时效性，当业务场景下数据发生变动，模型自然也需要更新迭代，如果模型简单的嵌入到业务服务当中，就会面临模型更新就要影响到整个业务服务上的改动。 基于上述可能面临的问题，提出基于docker容器的模型部署方式，解决以上问题的同时，该方式还具有以下优点：\n模型部署在K8S集群环境下，充分利用大规模集群资源 不同模型封装在一个docker容器当中，所以模型预估计算相互独立，支持对多个模型进行预估 可扩展性强，模型数量可扩展至百个，千个级别 关于Docker容器\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。\n【官方网站】https://www.docker.com/products/docker-desktop\n关于算法模型 这里算法不同于传统意义上的计算机算法，主要指机器学习算法，详情可见机器学习综述。而模型就是算法在训练结束后，学习到一组参数或者规则，而这些参数和规则保存在一定格式的文件当中，模型预估的过程就是加载这些文件到内存当中，传入数据特征进行计算，最终计算得到一个结果，不同类型的模型计算得到的结果形式不同，但是多数监督模型是以概率值的形式输出。\n经上表述，模型服务化的目的简单来说就是将模型文件中保存的参数或者规则常驻到内存， …","date":1580860800,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":3100,"html":"本文根据在工作中遇到的真实业务场景提出的技术实施方案","keywords":null,"kind":"page","lang":"en","lastmod":1580860800,"objectID":"ed883323bd94f384086918e3d0ca3871","permalink":"https://bytewalking.github.io/post/2020-02-06-docker-and-model-deployment/","publishdate":"2020-02-05T00:00:00Z","readingtime":6,"relpermalink":"/post/2020-02-06-docker-and-model-deployment/","section":"post","tags":["docker","python","tensorflow"],"title":"基于Docker容器的算法模型部署","type":"post","url":"/post/2020-02-06-docker-and-model-deployment/","weight":0,"wordcount":3003},{"author":null,"categories":["Tech"],"content":"从古至今，长江和黄河流域水患不断，远古时期大禹曾拓宽河道，清除淤沙让流水更加顺畅；都江堰作为史上最成功的的治水案例之一，用引流将岷江之水分流到多个支流中，以分担水流压力；三门峡和葛洲坝通过建造水库将水引入水库先存储起来，然后再想办法把水库中的水缓缓地排出去，以此提高下游的抗洪能力。而我们在应对高并发大流量时也会采用类似“抵御洪水”的方案，归纳起来共有三种方法。\nScale-out（横向扩展）：分而治之是一种常见的高并发系统设计方法，采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。\n缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。\n异步：在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。\n这三种方法可以在做方案设计时灵活地运用，但它不是具体实施的方案，而是三种思想，在实际运用中会千变万化。\n一 . 数据库篇 池化技术减少频繁创建连接的损耗\n一般sql的平均执行时间是1ms，而数据库建立连接的时间需要4ms，这样一秒大概执行200次数据库查询，如果我们事先用连接池将数据库连接预先建立好，这样在使用的时候就不需要频繁地创建连接了。调整之后，你发现 1s 就可以执行 1000 次的数据库查询，查询性能大大的提升了。\n在开发过程中我们会用到很多的连接池，像是数据库连接池、HTTP 连接池、Redis 连接池等等。而连接池的管理是连接池设计的核心，以数据库连接池为例，来说明一下连接池管理的关键点。数据库连接池有两个最重要的配置：最小连接数和最大连接数，它们控制着从连接池中获取连接的流程： 如果当前连接数小于最小连接数，则创建新的连接处理数据库请求； 如果连接池中有空闲连接则复用空闲连接； 如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求； 如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间（C3P0 的连接池配置是 checkoutTimeout）等待旧的连接可用； 如果等待超过了这个设定时间则向用户抛出错误。 对于数据库连接池，一般在线上建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。那么，怎么保证你启动着的连接一定是可用的呢？\n启动一个线程来定期检测连接池中的连接是否可用，比如使用连接发送 …","date":1579132800,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":13400,"html":"这是一篇把“高并发系统设计”讲得像“治水史诗”一样的文章。从大禹拓河、都江堰分流，到现代水库蓄洪，这些古老智慧被抽象成三种应对洪峰流量的技术之道：横向扩展、缓存加速、异步削峰。文章以此为总纲，在数据库层深入展开，从池化技术到主从复制，从分库分表到分区键的权衡，用实际经验拆解每一个工程师都会遇到的性能瓶颈。本质上，它讲的是：当流量像洪水一样倾泻而来，系统如何不被吞没，而是化压力为秩序、化混乱为韧性。","keywords":null,"kind":"page","lang":"en","lastmod":1579132800,"objectID":"a7deb7f00e34c38ffe0e4f46a97332d0","permalink":"https://bytewalking.github.io/post/2020-01-16-high-concurrency-system-design/","publishdate":"2020-01-16T00:00:00Z","readingtime":27,"relpermalink":"/post/2020-01-16-high-concurrency-system-design/","section":"post","tags":["MySQL","Redis"],"title":"浅谈如何设计一个高并发系统","type":"post","url":"/post/2020-01-16-high-concurrency-system-design/","weight":0,"wordcount":13345},{"author":null,"categories":["Life"],"content":"光阴如白驹过隙，转眼半年已过。作为虎扑员工 193 天，作为虎扑用户 208 天，这份工作既是毕业后的第一站，也是人生新阶段的开幕。我想借这篇总结，回望自己的心理历程、工作经验、未完成的计划与对未来的期待。\n一、心理成长与焦虑的来处 刚入职时，我在困惑与焦虑中度过。环境陌生、节奏迅速，而自己的能力又达不到心中预期，与身边的优秀同事对比更加强化了落差。随着阅读霍妮《我们内心的冲突》，我逐渐理解：\n焦虑的本质：能力与期望不匹配、依赖他人认可、习惯性比较。 外在表现：急于求成、容易受挫、对棘手任务畏缩、对模糊任务拖延。 缓解方式：沉入代码中暂逃焦虑；重新寻找自我定位；理解情绪只是“内心状态的仪表盘”，没有好坏，只是提示。 二、工作经验：实践、跌撞与顿悟 1. 爬虫项目的全流程历练 接手爬虫任务后，前期用 Python 快速起步，但随着范围扩大，问题密集出现：\n抓取速度慢、漏爬、频繁报错 数据间高度关联，漏爬一处牵连多处 框架提高速度但降低灵活性 最后通过分析目标网站 URL 规律，定位球员 ID，实现全站数据抓取。\n沉淀下来的经验：\n不要急着写代码：新项目开始前要先计划、先分析、先定位难点。 工程师的责任不可外包： 逻辑不能依赖产品 质量不能依赖测试 必须深入理解业务、主动思考 计划要可执行且有压力：\n模糊任务容易拖延，设置“能推动自己的节点”（如周会展示、合作依赖、博客输出）很关键。 2. 团队协作与身边的“小小英雄” 在虎扑的半年，我遇到很多让我敬佩的同事：\n中业大哥：为了生产故障整夜留守 超哥：入职第二天就处理问题到深夜 周围的同事：闲暇时间依然维护自己的项目 他们像“代码世界里的守夜人”，追求极致的质量，守护线上稳定。我曾经像个需要保护的小孩，而他们是心中的“小小英雄”。\n直到某晚我也为了解决难题忙到 9 点，走出公司时脚步竟有些轻快——原来自己也在向他们靠近。\n3. 黑客马拉松：半年最亮的时刻 这一刻毫无疑问是黑马一等奖。\n团队分工完整：\n我：模型构建与部署 超哥：数据整合与接口 媛媛：前端展示 曾老师：美术与 PPT 木可：产品＋爬虫 团队的力量让我完成了一个人无法做到的事，也让我真正理解“一个优秀团队胜过任何单点天才”。\n三、兴趣与个人成长（以及遗憾） 工作外，我尝试过游戏开发、阅读、健身等方向：\n想做像素迷宫游戏，因依赖问题搁置 许多书只看了开头，没有沉淀 …","date":1577577600,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1300,"html":"这是一篇写给“心中的小小英雄”的长信。它记录了我从无忧的工作节奏，走向责任与冲锋的世界；记录了我如何在一次次的加班与崩溃边缘，看见身边人的光，也重新看见自己的光。它也是一份献给虎扑文化的温柔注脚：那些绿得发亮的故事，那些可笑又可怜的小人物，那些在平凡生活中偷偷蓄力的灵魂。若你也曾怀疑自己是否微不足道，那么希望这篇文字能告诉你——渺小的人，也能有英雄的一刻。","keywords":null,"kind":"page","lang":"en","lastmod":1577577600,"objectID":"6d226047014eed1954cc90de7f7ed084","permalink":"https://bytewalking.github.io/post/2019-12-29-2019-summarize/","publishdate":"2019-12-29T00:00:00Z","readingtime":3,"relpermalink":"/post/2019-12-29-2019-summarize/","section":"post","tags":["hoopchina","think"],"title":"2019年度总结","type":"post","url":"/post/2019-12-29-2019-summarize/","weight":0,"wordcount":1213},{"author":null,"categories":["Life"],"content":"我为什么要写这篇博客 前天看了《奇葩说》第六季第 5 期，辩题是“感兴趣的工作总是 996，我该不该 886”。节目还没看完，我就想起当年在 Embark 的日子。那时候一到点，开发组办公室瞬间清空，像被风卷走一样。那样的生活很好，你能留给自己足够的时间去沉思——但人一旦想得太久，就容易心里发痒，不安分了。\n为了所谓的“远大前程”，我挥泪告别那种无忧的生活。\n刚到虎扑时，我发现明明规定六点下班，但大多数人都要搞到七点之后。几天后我才意识到：原来七点有加班餐。暗叹一句资本家的套路深，我便每天七点准时“吃完就走”。\n虽然 hoop 不会强制你“修福报”，但天灾人祸总会降临，某些时候加班就是不可避免。产品同事告诉我，leader 曾无数次为了紧急故障整夜留守公司——这是他选择追随 leader 的原因：能力越大，责任越大。\n带我的大哥更是传奇：到公司第二天就修生产问题修到晚上十一点，第二天照常准时上班。隔壁桌的老哥闲暇时仍坚持维护自己的开源项目。\n这些鲜活的形象在我心里慢慢汇聚成一个画面——小小英雄的群像。\n我站在他们身旁，就像一个需要保护的孩子，既佩服又遥不可及。\n直到某天，我为了一个疑难问题熬到晚上九点。走在回家的路上，脚步轻得像踩在云上。那一刻我突然明白：\n原来我也在成为他们的一员。\n那种纯粹的快乐不比第一次解出算法题时的兴奋强烈，却让我重新找回“编程这件事”本身的乐趣。当世界被一个个可量化的对象描述，当脑海里的逻辑被敲进代码，当混乱的关系被模式和算法温柔重构——\n我他妈的就是世界上最快乐的人。\n如果可以，我愿意把这样的瞬间记录得再多一点，只为自己足够的时候能回头看看。\n毕竟，我经常面对的困惑从不是“感兴趣的工作总是 996，要不要 886”，而是那些永远追问你“你怎么还不 886”的声音。\n所以我需要小小英雄。\n心中的小小英雄 在直文化里，我们相信每个人心里都住着一个小小英雄。 TA常被工作、学习、社交的压力包裹，不易显露。 可一旦出现，TA渴望胜利，勇于负责，也会照顾弱者。 极致时，TA是披上中国队战袍的姚明，是少室山上那句 “尔等齐上，萧某何惧”，是“两弹一星”的元勋。 在普通人中，TA是野球场的汗水、高考夜的冲刺、为了家人 再加的那几个小时的班。 —— CK，2019.9.15 CK 这段话我非常喜欢。因为他想打造的是一个“让小小英雄回血”的地方，而不是一个 …","date":1574812800,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2200,"html":"相信每个人心里都住着一个小小英雄。很多时候,TA会被工作,学习和社交的压力包裹住,不易辨别。但每当这个小小英雄显露出来,TA总是渴望竞争胜利,勇于承担责任,愿意照顾身旁的弱者。","keywords":null,"kind":"page","lang":"en","lastmod":1574812800,"objectID":"edd5bf06898b5e8c51bb7ee88cf454ce","permalink":"https://bytewalking.github.io/post/2019-11-27-hello-hoopchina-hero/","publishdate":"2019-11-27T00:00:00Z","readingtime":5,"relpermalink":"/post/2019-11-27-hello-hoopchina-hero/","section":"post","tags":["hoopchina","think"],"title":"心中的小小英雄","type":"post","url":"/post/2019-11-27-hello-hoopchina-hero/","weight":0,"wordcount":2170},{"author":null,"categories":["Tech"],"content":"通过expalin可以得到 表的读取顺序 表的读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 如何调用expalin命令 只需要在SELECT前面加上EXPLAIN即可，例如\nexplain select surname,first_name form a,b where a.id=b.id 在语句结尾(;之前)加上\\G能够更清晰的查看\n需要说的是EXPLAIN只对SELECT查询作解释,INSERT,UPDATE,DELETE不会\nExplain显示的列 id 语句的执行顺序标识，如果在语句中没有子查询或联合,说明只有一个SELECT,于是这个列显示为1,否则内层的SELECT会顺序编号\nselect_type 显示了对应的查询是简单还是复杂SELECT，主要有以下几种查询类型\n类型 解释 simple 简单类型 语句中没有子查询或union primary 最外层的select ，不是主键 这是为更复杂的查询而创建的首要表(也就是最外层的表)。这个类型通常可以在DERIVED 和UNION 类型混合使用时见到。 union union是在select 语句中第二个select语句后面所有的select，第一个select 为primary 这是UNION 语句其中的一个SQL 元素。 dependent subquery 子查询中内层中第一个select语句 这个select-type 值是为使用子查询而定义的。下面的SQL语句提供了这个值： mysql\u0026amp;gt; EXPLAIN SELECT p.* -\u0026amp;gt; FROM parent p -\u0026amp;gt; WHERE p.id NOT IN (SELECT c.parent_id FROM child c); dependent union 子查询中union且为union中第二个select开始的后面所有select，依赖于外部的结果集。 SUBQUERY 子查询内层查询的第一个SELECT，结果不依赖于外部查询结果集。 devived 派生表的查询语句当一个表不是一个物理表时，那么就被叫做DERIVED。下面的SQL 语句给出了一个QEP 中DERIVED select-type 类型的示例：mysql\u0026amp;gt; EXPLAIN SELECT …","date":1564790400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":3500,"html":"这是一份深入拆解 MySQL EXPLAIN 输出的完整指南。它不仅告诉你每一列的意义，更带你理解优化器在背后是如何思考、如何选择索引、如何决定访问路径。你会看到查询被逐层剖开：执行顺序、连接方式、扫描类型、索引利用率、行数预估、额外优化策略……所有那些原本藏在 MySQL 黑箱里的决策，都在这里变得清晰透明。","keywords":null,"kind":"page","lang":"en","lastmod":1564790400,"objectID":"8984e9fc822a97d2b38a9b2ebad7e269","permalink":"https://bytewalking.github.io/post/2019-08-02-mysql-explain-interpretation/","publishdate":"2019-08-03T00:00:00Z","readingtime":7,"relpermalink":"/post/2019-08-02-mysql-explain-interpretation/","section":"post","tags":["mysql","index"],"title":"通过expalin可以得到什么？","type":"post","url":"/post/2019-08-02-mysql-explain-interpretation/","weight":0,"wordcount":3491},{"author":null,"categories":["Tech"],"content":"Guava Cache是在内存中缓存数据，相比较于数据库或redis存储，访问内存中的数据会更加高效。Guava官网介绍，下面的这几种情况可以考虑使用Guava Cache：\n愿意消耗一些内存空间来提升速度。\n预料到某些键会被多次查询。\n缓存中存放的数据总量不会超出内存容量。\n所以，可以将程序频繁用到的少量数据存储到Guava Cache中，以改善程序性能。下面对Guava Cache的用法进行详细的介绍。\n构建缓存对象 接口Cache代表一块缓存，它有如下方法：\npublic interface Cache\u0026amp;lt;K, V\u0026amp;gt; { V get(K key, Callable\u0026amp;lt;? extends V\u0026amp;gt; valueLoader) throws ExecutionException; ImmutableMap\u0026amp;lt;K, V\u0026amp;gt; getAllPresent(Iterable\u0026amp;lt;?\u0026amp;gt; keys); void put(K key, V value); void putAll(Map\u0026amp;lt;? extends K, ? extends V\u0026amp;gt; m); void invalidate(Object key); void invalidateAll(Iterable\u0026amp;lt;?\u0026amp;gt; keys); void invalidateAll(); long size(); CacheStats stats(); ConcurrentMap\u0026amp;lt;K, V\u0026amp;gt; asMap(); void cleanUp(); } 可以通过CacheBuilder类构建一个缓存对象，CacheBuilder类采用builder设计模式，它的每个方法都返回CacheBuilder本身，直到build方法被调用。构建一个缓存对象代码如下。\npublic class StudyGuavaCache { public static void main(String[] args) { Cache\u0026amp;lt;String,String\u0026amp;gt; cache = CacheBuilder.newBuilder().build(); cache.put(\u0026amp;#34;word\u0026amp;#34;,\u0026amp;#34;Hello Guava Cache\u0026amp;#34;); …","date":1564617600,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":3800,"html":"虽然不用自己造轮子，但是要弄懂轮子是怎么跑起来的，以后有时间会把谷歌原版的Guava教程翻译出来","keywords":null,"kind":"page","lang":"en","lastmod":1564617600,"objectID":"42298e77653ebbcf333d61868bf74583","permalink":"https://bytewalking.github.io/post/2019-08-01-guava-cache-guide/","publishdate":"2019-08-01T00:00:00Z","readingtime":8,"relpermalink":"/post/2019-08-01-guava-cache-guide/","section":"post","tags":["Guava","Cache","Java"],"title":"Guava Cache 用法指南","type":"post","url":"/post/2019-08-01-guava-cache-guide/","weight":0,"wordcount":3764},{"author":null,"categories":["Tech"],"content":"Java 8 Iterable.forEach() vs foreach loop Which of the following is better practice in Java 8?\nJava 8:\njoins.forEach(join -\u0026amp;gt; mIrc.join(mSession, join)); Java 7:\nfor (String join : joins) { mIrc.join(mSession, join); } I have lots of for loops that could be \u0026amp;ldquo;simplified\u0026amp;rdquo; with lambdas, but is there really any advantage of using them? Would it improve their performance and readability?\nEDIT\nI\u0026amp;rsquo;ll also extend this question to longer methods. I know that you can\u0026amp;rsquo;t return or break the parent function from a lambda and this should also be taken into consideration when comparing them, but is there anything else to be considered?\nAnswer The better practice is to use for-each. Besides violating the Keep It Simple, Stupid principle, the new-fangled forEach() has at least the following deficiencies:\nCan\u0026amp;rsquo;t use non-final variables. So, code like the following can\u0026amp;rsquo;t be turned into a forEach lambda:\nObject prev = null; for(Object curr : list) { if( prev != null ) …","date":1564531200,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1000,"html":"这是英文原文，我后期会对此进行翻译","keywords":null,"kind":"page","lang":"en","lastmod":1564531200,"objectID":"50b84f41468007705eec2b1321fbe709","permalink":"https://bytewalking.github.io/post/2019-07-31-java-8-foreach-vs-foreach-loop/","publishdate":"2019-07-31T00:00:00Z","readingtime":2,"relpermalink":"/post/2019-07-31-java-8-foreach-vs-foreach-loop/","section":"post","tags":["java8","性能"],"title":"Java 8 Iterable.forEach() vs foreach loop","type":"post","url":"/post/2019-07-31-java-8-foreach-vs-foreach-loop/","weight":0,"wordcount":957},{"author":null,"categories":["Tech"],"content":"重要概念 REST,即Representational State Transfer的缩写，翻译过来就是\u0026amp;quot;表现层状态转化\u0026amp;quot;。\nResource（资源） ：对象的单个实例。例如，一只动物。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。\n集合：对象的集合。例如，动物。\n第三方：使用我们接口的开发者\n表现层（Representation）：\u0026amp;ldquo;资源\u0026amp;quot;是一种信息实体，它可以有多种外在表现形式。我们把\u0026amp;quot;资源\u0026amp;quot;具体呈现出来的形式，叫做它的\u0026amp;quot;表现层\u0026amp;rdquo;（Representation）。\n状态转化（State Transfer） 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\u0026amp;quot;状态转化\u0026amp;quot;（State Transfer）。而这种转化是建立在表现层之上的，所以就是\u0026amp;quot;表现层状态转化\u0026amp;quot;。\n综合上面的解释，我们总结一下什么是RESTful架构：\n每一个URI代表一种资源；\n客户端和服务器之间，传递这种资源的某种表现层；\n客户端通过HTTP动词(GET,POST等等)，对服务器端资源进行操作，实现\u0026amp;quot;表现层状态转化\u0026amp;quot;。\nREST接口规范 动作 GET （SELECT）：从服务器检索特定资源，或资源列表。\nPOST （CREATE）：在服务器上创建一个新的资源。\nPUT （UPDATE）：更新服务器上的资源（客户端提供更新后的整个资源）。\nPATCH （UPDATE）：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新）。\nDELETE （DELETE）：从服务器删除资源。\n路径（接口命名） 路径又称\u0026amp;quot;终点\u0026amp;quot;（endpoint），表示API的具体网址。\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词 …","date":1564531200,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":3500,"html":"从最基础的 REST 概念讲起，把资源、表现层、状态转化这些抽象名词拆解得一目了然，再逐步引导你进入真正重要的领域：如何设计一个清晰、优雅、可预期的 API。它不仅涵盖路径命名、HTTP 动作、版本控制、过滤参数与状态码的系统化规范，还延伸到常被忽略却极具价值的 HATEOAS——让 API 像一本自带目录的书，能指引客户端自然地探索下一步。","keywords":null,"kind":"page","lang":"en","lastmod":1564531200,"objectID":"2e0a060126ef093afb5c7552e2440c4b","permalink":"https://bytewalking.github.io/post/2019-07-31-restful-api-essential-knowledge/","publishdate":"2019-07-31T00:00:00Z","readingtime":7,"relpermalink":"/post/2019-07-31-restful-api-essential-knowledge/","section":"post","tags":["API","basic"],"title":"RestFul API 知识总结","type":"post","url":"/post/2019-07-31-restful-api-essential-knowledge/","weight":0,"wordcount":3485},{"author":null,"categories":["Tech"],"content":"我其实就是想水一篇，反正也没人看。公司给来我一个参加技术大佬们周例会的机会，做了一些笔记分享一下\n9PM项目周会笔记19/7/22 第一部分:故障分析 对Q2的故障数据进行分析和总结，数据来源CMDB，分成三个部分进行分析\n篮球 基于数据的故障比较多，数据是个比较大的问题\n基础设施部分也有故障\n足球的故障和篮球类似，数据出问题的概率比较大\n社区 大部分故障是大流量造成\n大流量问题相对 安全、误操作等问题更好解决\n基础(搜索、推荐、基础设施) 大流量占比还是比较大，运维在定时任务、DBA在建立索引等部分容易发生故障\n处理时长 大流量问题容易处理（30分钟内），安全和上云问题较难处理（12小时以上）\n总结 故障分析总结\n篮球的故障主要是数据导致 社区的故障主要是大流量导致 基础运维的故障主要是操作导致 社区和基础都涉及到安全问题 故障问题和流量大小成正比 下周的会议会分享改进措施\n个人总结 因为我目前在足球组工作，足球组GDC面临的问题和篮球组类似，所以对篮球组数据故障高发很有感受，逻辑bug很少，大部分需要处理的bug都是在为数据源问题打补丁\n从我遇到过的问题和工作中的实际情况来看，足球组数据故障的原因有\n数据源种类太多（多个第三方接入、爬虫、游戏数据导入），缺乏一种灵活切换数据源数据的策略 数据源不稳定，很多比赛数据由第三方提供，有时推送过来的数据有误，需要建立数据校验机制 测试困难，因为比赛数据是实时提供的，而我们没有赛事回放功能，导致测试的工作推进缓慢 运营操作失误，没有对运营的操作进行后台约束 目前篮球和足球大部分的比赛都处于一个休赛期，大流量导致的故障并不多，但从社区的故障分析来看，如何应对大流量也是有必要重点考虑的。在足球GDC的重构计划中，这些故障分析很有指导意义，算是前车之鉴吧，新版的GDC架构也针对这些问题做了相应的处理。\n第二部分:立项申请-文档平台2.0 申请人在目标、策略和计划、资源需求这三个方面未与大家达成共识，项目需要再议\n申请人的目标 目前文档平台1.0运作过程中产生了缺乏标准、互动少、文档查找困难等缺陷\n申请人的目标是先做活一个板块,增加互动，衡量质量, 最终能够提升整体研发的氛围,做好技术沉淀\n申请人的策略和计划 成立文案评委 创立一个虚拟组织极客团，理想状态的极客团成员由公司内热爱技术，乐于奉献的人员组成\n每个人在“分享殿堂”内的基 …","date":1563840000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2600,"html":"我其实就是想水一篇，反正也没人看。公司给来我一个参加技术大佬们周例会的机会，做了一些笔记分享一下","keywords":null,"kind":"page","lang":"en","lastmod":1563840000,"objectID":"648073c15aba738192fff19b321e6348","permalink":"https://bytewalking.github.io/post/2019-07-23-meeting-notes/","publishdate":"2019-07-23T00:00:00Z","readingtime":6,"relpermalink":"/post/2019-07-23-meeting-notes/","section":"post","tags":["Blog"],"title":"技术例会会议记录","type":"post","url":"/post/2019-07-23-meeting-notes/","weight":0,"wordcount":2583},{"author":null,"categories":["Tips"],"content":"Mac端环境变量配置 Mac使用bash做为默认的shell\nMAC OS X环境配置的加载顺序\n### 系统级别 /etc/profile /etc/paths ### 用户级别 /.bash_profile /.bash_login /.profile /.bashrc 前两个是系统级别的环境变量，针对所有用户，后面四个带有 ~/ 用户级别的环境变量。\n前两个环境配置在系统启动时候就会加载。 ~/.bash_profile ，~/.bash_login ，~/.profile 依次加载，如果 ~/.bash_profile不存在，依次加载后面几个文件；如果 ~/.bash_profile 文件存在，后面几个文件不会加载\n~/.bashrc 是bash shell打开时候加载\n全局环境变量设置 修改全局环境变量时候参考系统默认的环境变量配置格式。\n修改全局环境变量需要root权限。\n/etc/paths 全局建议修改这个文件 /etc/profile 不建议修改这个文件，全局共有配置，用户登录时候都会加载该文件 /etc/bashrc 一般在这个文件中添加系统级别的环境变量，全局共有配置，bash shell执行时候都会加载 用户级别环境变量设置 在~/.bash_profile中配置环境。\n# 使用冒号隔开 export PATH=$PATH:\u0026amp;lt;PATH 1\u0026amp;gt;:\u0026amp;lt;PATH 2\u0026amp;gt;:\u0026amp;lt;PATH 3\u0026amp;gt;:------:\u0026amp;lt;PATH N\u0026amp;gt; # 或者 export PATH=${PATH}:\u0026amp;lt;PATH 1\u0026amp;gt; export PATH=${PATH}:\u0026amp;lt;PATH 2\u0026amp;gt; # 第一种将路径合并在一起，不方便删除，建议使用第二种，换行挨个设置 # java export JAVA_HOME = /home/myuser/jdk1.7.0_03 export PATH = $JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar # hadoop export HADOOP_HOME=/Users/YourUserName/Documents/Dev/hadoop-2.7.3 export …","date":1563667200,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":600,"html":"全面梳理 macOS 上 bash shell 的环境变量配置，包括系统级与用户级加载顺序、全局与用户变量设置方法、PATH 管理技巧，以及常见开发工具（Java、Hadoop、Python、Ant、JBOSS、Maven 等）的配置示例，并提供立即生效的方式。适合开发者快速上手和维护 Mac 环境变量","keywords":null,"kind":"page","lang":"en","lastmod":1563667200,"objectID":"4e4256db8ffd3ebbb392235b7c9104c3","permalink":"https://bytewalking.github.io/post/2019-07-21-mac-os-x-config/","publishdate":"2019-07-21T00:00:00Z","readingtime":2,"relpermalink":"/post/2019-07-21-mac-os-x-config/","section":"post","tags":["Tips","Mac"],"title":"Mac OS X配置环境变量","type":"post","url":"/post/2019-07-21-mac-os-x-config/","weight":0,"wordcount":564},{"author":null,"categories":["Tech"],"content":"曾经我问我的导师“如何才能把技术做深”，现在发现这个问题可能就是一个错误的问题。这种如何把技术做深的问题就好像是在问如何学好英语，如何成功。很多时候，面对很多问题，我们思考的方向，并非是怎么解决问题，而是，我们要解决的问题究竟是什么。\n今天我们从一道算法题来探讨这个问题。这道题的形式有很多种，但背后的算法是一致的。\n这个问题就是：\n设计一个公平的洗牌算法\n看问题，洗牌，显然是一个随机算法了。随机算法还不简单？随机呗。把所有牌放到一个数组中，每次取两张牌交换位置，随机 k 次即可。\n如果这是你的答案，那么K应该取多少？100？1000？10000？\n很显然，取一个固定的值不合理。如果数组中有 1000000 个元素，随机 100 次太少；如果数组中只有 10 个元素，随机 10000 次又太多。一个合理的选择是，随机次数和数组中元素大小相关。比如数组有多少个元素，我们就随机多少次。\n这个答案已经很好了，但是其实，连这个问题的本质都没有触及到。\n我们再看一看问题：设计一个公平的洗牌算法。\n那么问题又来了，对于一个洗牌算法来说，什么叫“公平”？这其实才是这个问题的本质。我们必须弄清楚：什么叫公平。\n一旦你开始思考这个问题，才触及到这个问题的核心。在我看来，不管你有没有给出正确的算法，如果你的思路是在思考对于洗牌算法而言，什么事“公平”，我都觉得你很优秀了。\n因为背出一个算法是简单的，但是这种探求问题本源的思考角度，绝不是一日之功。别人告诉你再多次“要定义清楚问题的实质”都没用。这是一种不断面对问题，不断解决问题，逐渐磨炼出来的能力，短时间内无法培训。\n说回我们的洗牌算法，什么叫公平呢？一旦你开始思考这个问题，其实答案不难想到。洗牌的结果是所有元素的一个排列。一副牌如果有 n 个元素，最终排列的可能性一共有 n! 个。公平的洗牌算法，应该能等概率地给出这 n! 个结果中的任意一个。\n如思考到这一点，我们就能设计出一个简单的暴力算法了：对于 n 个元素，生成所有的 n! 个排列，然后，随机抽一个。\n这个算法绝对是公平的。但问题是，复杂度太高。复杂度是多少呢？O(n!)。因为，n 个元素一共有 n! 种排列，我们求出所有 n! 种排列，至少需要 n! 的时间。\n有一些同学对 O(n!) 没有概念。我本科时就闹过笑话，正儿八经地表示 O(n!) 并不是什么大不了不起的复杂度。实际 …","date":1563148800,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2800,"html":"今天给大家介绍大名鼎鼎的Knuth-Shuffle算法","keywords":null,"kind":"page","lang":"en","lastmod":1563148800,"objectID":"6a840abf69acfe2a726a07d769ad0c26","permalink":"https://bytewalking.github.io/post/2019-07-15-fair-shuffling-algorithm/","publishdate":"2019-07-15T00:00:00Z","readingtime":6,"relpermalink":"/post/2019-07-15-fair-shuffling-algorithm/","section":"post","tags":["Algorithm"],"title":"公平的洗牌算法","type":"post","url":"/post/2019-07-15-fair-shuffling-algorithm/","weight":0,"wordcount":2762},{"author":null,"categories":["Tech"],"content":"Hello，Microservices 本人初学微服务，此文章是对自己所学的内容进行整理和总结，部分图片和文字来源网络，侵删。 我对相关知识的理解还不是很到位，随着学习的深入，本文也会随时被更新，如有发现了错误还请指出，感谢。\n什么是微服务 微服务Microservices之父，马丁.福勒，对微服务大概的概述如下：\n就目前而言，对于微服务业界并没有一个统一的、标准的定义（While there is no precise definition of this architectural style ) 。 但通在其常而言，微服务架构是一种架构模式或者说是一种架构风格，它提倡将单一应用程序划分成一组小的服务，每个服务运行独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API ) 。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。 另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务。可以使用不同的语言来编写服务，也可以使用不同的数据存储。 根据马丁.福勒的描述，总结了一下几点：\n小服务 小服务，没有特定的标准或者规范，但他在总体规范上一定是小的。 进程独立 每一组服务都是独立运行的，可能我这个服务运行在tomcat容器，而另一个服务运行在jetty上。可以通过进程方式，不断的横向扩展整个服务。\n通信 过去的协议都是很重的，就像ESB，就像SOAP，轻通信，着意味着相比过去更智能更轻量的服务相互调用，就所谓smart endpoints and dumb pipes，这些endpoint都是解耦的，完成一个业务通信调用串起这些micro service就像是linux系统中通过管道串起一系列命令业务。 过去的业务，我们通常会考虑各种各样的依赖关系，考虑系统耦合带来的问题。微服务，可以让开发者更专注于业务的逻辑开发。\n部署 不止业务要独立，部署也要独立。不过这也意味着，传统的开发流程会出现一定程度的改变，开发的适合也要有一定的运维指责\n管理 传统的企业级SOA服务往往很大，不易于管理，耦合性高，团队开发成本比较大。微服务，可以让团 …","date":1562716800,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":6900,"html":"我对相关知识的理解还不是很到位，随着学习的深入，本文也会随时被更新，如有发现了错误还请指出，感谢","keywords":null,"kind":"page","lang":"en","lastmod":1562716800,"objectID":"a6eb46377aa8ff1c31b6ea8623372120","permalink":"https://bytewalking.github.io/post/2019-07-10-micro-service-core-knowledge-collation-and-induction/","publishdate":"2019-07-10T00:00:00Z","readingtime":14,"relpermalink":"/post/2019-07-10-micro-service-core-knowledge-collation-and-induction/","section":"post","tags":["Microservice"],"title":"微服务核心知识整理与归纳","type":"post","url":"/post/2019-07-10-micro-service-core-knowledge-collation-and-induction/","weight":0,"wordcount":6834},{"author":null,"categories":["Tech"],"content":"Hugo is a static HTML and CSS website generator written in Go. It is optimized for speed, ease of use, and configurability. Hugo takes a directory with content and templates and renders them into a full HTML website.\nHow to Install Install Hugo as Your Site Generator (Binary Install) Homebrew (macOS)\nbrew install hugo Chocolatey (Windows)\nchoco install hugo -confirm Use the installation instructions in the Hugo documentation\nBuild and Install the Binaries from Source (Advanced Install) Prerequisite Tools:\nGit GO(at least Go 1.11) Fetch from GitHub\nSince Hugo 0.48, Hugo uses the Go Modules support built into Go 1.11 to build. The easiest is to clone Hugo in a directory outside of GOPATH, as in the following example:\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install If you are a Windows user, substitute the $HOME environment variable above with %USERPROFILE%.\nAfter the installation is complete, after entering the hugo version in the terminal, …","date":1557360000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":800,"html":"","keywords":null,"kind":"page","lang":"en","lastmod":1557360000,"objectID":"0ead053fcf6ae8fb86c7e4790cbad393","permalink":"https://bytewalking.github.io/post/2019-05-09-how-to-build-a-website-like-mine/","publishdate":"2019-05-09T00:00:00Z","readingtime":4,"relpermalink":"/post/2019-05-09-how-to-build-a-website-like-mine/","section":"post","tags":["Blog","GitHub"],"title":"How To Build A Personal Blog Site","type":"post","url":"/post/2019-05-09-how-to-build-a-website-like-mine/","weight":0,"wordcount":765},{"author":null,"categories":["Tech"],"content":"Hugo 是一款使用Go语言编写的静态语言生成器。它对构建速度，易用性和可配置性等方面进行了优化。Hugo的目录内包含content和templates等部分，并将它们打包呈现为一个完整的HTML网站\n如何安装 安装Hugo作为您的站点生成器 (二进制安装) Homebrew (macOS)\nbrew install hugo Chocolatey (Windows)\nchoco install hugo -confirm 阅读更多关于安装hugo的教程文档Hugo使用文档\n使用源码编译和安装二进制文件（高级安装） 所需工具:\nGit GO(at least Go 1.11) 从GitHub获取源码 自Hugo 0.48 以来，Hugo使用Go 1.11内置的Go Modules支持来构建。 最简单的方法是在GOPATH之外的目录中克隆Hugo，如下例所示：\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install 如果你是window用户, 用％USERPROFILE％替换上面的$ HOME环境变量。\n完成安装后, 在终端内输入 hugo version , 如果显示 Hugo Static Site Generator v0.55.0-DEV linux/amd64 BuildDate: unknown ,就表明安装成功了\n安装主题 你正在访问的博客网站使用的主题是\u0026amp;quot;hugo-theme-cleanwhite\u0026amp;quot;,在本教程中也以这个主题为例子\n学习使用此主题最简单的方法是从使用了此主题的示例网站开始，然后您可以随意修改并添加自己的东西。\n$ mkdir test $ cd test $ mkdir themes $ cd themes $ git clone https://github.com/zhaohuabing/hugo-theme-cleanwhite.git $ cp -r hugo-theme-cleanwhite/exampleSite/** ../ $ cd .. $ hugo serve 如果您的站点已经是一个git项目，您可能希望选择将cleanwhite主题添加为子模块，以避免弄乱现有的 …","date":1557360000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1700,"html":"","keywords":null,"kind":"page","lang":"en","lastmod":1557360000,"objectID":"13223c2655f54a20f72619739b1c1a7d","permalink":"https://bytewalking.github.io/post/2019-05-09-how-to-build-a-website-like-mine-chinese/","publishdate":"2019-05-09T00:00:00Z","readingtime":4,"relpermalink":"/post/2019-05-09-how-to-build-a-website-like-mine-chinese/","section":"post","tags":["Blog","GitHub"],"title":"How To Build A Personal Blog Site(中文版)","type":"post","url":"/post/2019-05-09-how-to-build-a-website-like-mine-chinese/","weight":0,"wordcount":1625},{"author":null,"categories":["Tech"],"content":"单系统登录机制 http无状态协议 Web应用一般都是采用browser/server架构，使用http作为通信协议。http是无状态协议，浏览器的每一次请求，服务器都会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系\n但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然http协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制\n会话机制 浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器，浏览器存储会话id，并在后续第二次和第三次请求中带上会话id，服务器取得请求中的会话id就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联\n服务器在内存中保存会话对象，浏览器怎么保存会话id呢？你可能会想到两种方式\n请求参数 cookie 将会话id作为每一个请求的参数，服务器接收请求自然能解析参数获得会话id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话id吧，每次发送http请求时浏览器自动发送会话id，cookie机制正好用来做这件事。cookie是浏览器用来存储少量数据的一种机制，数据以”key/value“形式存储，浏览器发送http请求时自动附带cookie信息\ntomcat会话机制当然也实现了cookie，访问tomcat服务器时，浏览器中可以看到一个名为“JSESSIONID”的cookie，这就是tomcat会话机制维护的会话id，使用了cookie的请求响应过程如下图\n登录状态 有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat在会话对象中设置登录状态如下\nHttpSession session = request.getSession(); …","date":1557273600,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":3400,"html":"sso认证中心为Django搭建的web应用,发送请求认证的系统为GWT搭建的web应用,所以实现中使用Python和Java语言分别完成请求和响应这两步操作,本方案最终实现了跨语言技术平台登录","keywords":null,"kind":"page","lang":"en","lastmod":1557273600,"objectID":"e0f1c42a74002b9eaeae977a0d649d4e","permalink":"https://bytewalking.github.io/post/2019-05-08-single-sign-on-design-and-implementation/","publishdate":"2019-05-08T00:00:00Z","readingtime":7,"relpermalink":"/post/2019-05-08-single-sign-on-design-and-implementation/","section":"post","tags":["SSO","Django","GWT","Python","JAVA"],"title":"单点登录的原理和实现","type":"post","url":"/post/2019-05-08-single-sign-on-design-and-implementation/","weight":0,"wordcount":3354},{"author":null,"categories":["Tips"],"content":"文章转自阿里巴巴高级无线开发专家江建明\n一、如何阅读本文？ 找一个固定不被打扰时间仔细阅读。 在碎片化的时间中，每次读完一段内容。\n最重要的是每次做到只字不差的阅读，然后停下，带着批判性思维从本文中提取出你觉得对的思考方式，并把思考方式关联和迁移到自己身上，经过实践内化成自己的认知，就是非常成功的一次阅读。\n二、开始认识“认知升级” 第一次：从文章中看到认知升级，认为认知升级是洗脑，是鸡汤，我对此不屑一顾，道理谁都懂，大部分人还不是过得一样，没啥区别。\n第二次：从会场里听到认知升级，一个活人站在那里讲认知升级，觉得认知升级有点意思，开始慢慢去理解认知升级，但还是不懂认知升级的价值。\n第三次：从实践中觉知认知升级，发现“鸡汤谁都懂，但依然过不好这一生”，还有另外一个版本“用好喝鸡汤的工具：汤勺，可以把这一生过得很好”，最简单的开始就是从时间管理认知升级开始，感受到认知升级的强大力量。自从换了一种时间管理思考方式之后，自己逐渐变得自律，变得有思考，成长复利慢慢变厚，感受到认知升级的价值，但还是没能力定义认知升级。\n第四次：从利TA中定义认知升级，开始做认知升级的PPT给团队，给他人分享认知升级，发现一部分人的行为、工作、思考等在慢慢发生变化，这些发生变化的同学，未来肯定会超出自己的期望，变得更加优秀，此时我想我能够比较清晰地定义认知升级。\n我对认知升级的定义：认知升级是连接，连接优秀的思维方式，连接解决问题的最短路径，连接一切优秀的方法。比如：说到时间管理立马连接到“找到不被打扰的时间用于投资自己”、说到执行力立马连接到“先想明白，然后一步步做下去”、说到改变习惯立马连接到“在触发条件发生进入下一个行为时，做对选择题”。通过认知的改变，会激发自己做出思考，做出行为的改变，从而影响我们的判断，提升我们的能力，确切地说认知升级颠覆了自己的思考习惯，让我们超越本能思考，摆脱了旧有的直觉和经验，建立起了新的直觉和经验。\n下面10个主题的认知分享是从我的认知升级库中挑出来的一部分我认为最重要的认知，对我的帮助和改变非常大，我相信对其他人同样有价值，大道至简，坚持这10个简单的认知就可以大大提升我们的成长速度，而且随着自我不断进化的同时，会不断升级和丰富自己的认知库，不断提升自己的认知升级能力。\n1. 思考脑与反射脑 听精彩的演讲不止精神上会有即时的瞬间享受和满足感，更重要的是总会 …","date":1557100800,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":12900,"html":"阿里有句非常经典的土话，“今天的最好表现，是明天的最低要求。”如何挖掘潜能、发现更好的自己？今天，阿里巴巴高级无线开发专家江建明将认知升级的方法总结出来，帮助你获得快速成长的秘诀（本文内容稍长但值得细细阅读哦）。","keywords":null,"kind":"page","lang":"en","lastmod":1557100800,"objectID":"b316864b5a093f95543b7087b5f5f45f","permalink":"https://bytewalking.github.io/post/2019-5-6-10-simple-tips-for-engineers/","publishdate":"2019-05-06T00:00:00Z","readingtime":26,"relpermalink":"/post/2019-5-6-10-simple-tips-for-engineers/","section":"post","tags":["think-deeply"],"title":"致工程师的10个简单技巧","type":"post","url":"/post/2019-5-6-10-simple-tips-for-engineers/","weight":0,"wordcount":12875},{"author":null,"categories":["Life"],"content":"在网上翻阅大佬们的博客时发现了这个利器社群计划,正好最近自己也在写博客,就把这些问题也记录下来吧\n介绍一下你自己和所做的工作。 我是一名即将毕业，但是已经入行半年多的程序员,目前在一家留学教育公司做web开发工作\n你的职业生涯的转折点是什么？ 职业生涯才刚刚开始,不觉得有什么转折点,目前是很期待出现具有挑战性的工作机会\n你都在使用哪些硬件？ 计算机: Mac Pro 13\n从Window到Linux再到现在的Mac，最终发现还是Mac最适合我。这台机子现在是我的主要生产工具,因为平时经常带着电脑出门自习(以前一直背着15寸电脑的巨大电脑包出门,饱受巨大电脑包折磨/(ㄒoㄒ)/),所以还是舍弃了15寸的性能买了13寸,如果只是用来编程的话,13寸Pro的性能完全够用\nLenovo XiaoXing\n这台陪我度过大学时光的笔记最终还是被我刷上Linux操作系统,被我用来做各种实验.在买Mac前工作时还会带上她,虽然在Linux做开发时爽的要飞起来,但是因为缺少大量生活和社交软件,遇到某些问题就会变得超级麻烦。但是使用Linux这段时间让我学到了很多好玩的东西\nRaspberry Pi\n大学时买的Raspberry Pi 3 Model B,可以安装树莓派定制的Linux操作系统,各种传感器也可以通过GPIO接口连接到树莓派,大二时用它做了个带摄像头可以在Web端远程控制小车,然后就装上了很多传感器,做成一个很奇怪的东西.现在没那么多时间折腾这些硬件了,已经吃了很久的灰了\nG502\n这款鼠标也是大学时入手的，那时还比较喜欢玩游戏，又发现这是一款可编程鼠标，就入手了。鼠标上的呼吸灯还是很抢眼的，鼠标灵敏度也可以顺滑切换，但是用惯了Mac的触控板后就不再想用鼠标了\nHHKB Pro BT\n这款键盘很配合mac使用，静电容键盘，稳定、迅速、全键无冲突、无比灵敏，也没有机械键盘烦人的敲击声。无键印的键盘，让人感觉b格很高。码农最常接触设备就是键盘了，所以拥有一个合手的键盘非常重要\n手机 iPhone XR\n以前那位陪我度过3年青葱岁月的Samsung爆炸了.啊不是,是进水身亡了.正好遇到苹果手机疯狂降价,就入手了.用起来体验很棒,但对于爱折腾的我来说,苹果系统的封闭让我缺失了好多乐趣,还是很怀念用Samsung时各种魔改的日子\n泡面盖 Kindle\n我追女票时,以为她和我一样是个 …","date":1557014400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2500,"html":"在网上翻阅大佬们的博客时发现了这个利器社群计划,正好最近自己也在写博客,就把这些问题也记录下来吧，将我使用的工具分享出来","keywords":null,"kind":"page","lang":"en","lastmod":1557014400,"objectID":"ced2c4ef21c1075f75b9714edada4eb9","permalink":"https://bytewalking.github.io/post/2019-4-25-creators-and-their-tools/","publishdate":"2019-05-05T00:00:00Z","readingtime":5,"relpermalink":"/post/2019-4-25-creators-and-their-tools/","section":"post","tags":null,"title":"创造者和他们的工具——我的利器","type":"post","url":"/post/2019-4-25-creators-and-their-tools/","weight":0,"wordcount":2412},{"author":null,"categories":["Tips"],"content":"环境变量 修改当前用户\nvim ~/.bashrc 例：设置java环境变量\n#set oracle jdk environment export JAVA8=/usr/lib/jvm/jdk1.8.0_191 export JAVA7=/usr/lib/jvm/jdk1.7.0_80 export JAVA_HOME=${JAVA7} export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH export PATH=/usr/appengine/appengine-java-sdk-1.9.66//bin:$PATH export PATH=/usr/apache-ant-1.9.13//bin:$PATH export PS1=\u0026amp;#34;\\[\\e[32m\\]\\w\\[\\e[m\\]\\[\\e[32m\\] \u0026amp;gt;\\[\\e[m\\] \u0026amp;#34; 使环境变量马上生效：\nsource ~/.bashrc 用于所有用户：\nsudo vim /etc/profile source /etc/profile 测试当前环境变量：\necho $PATH 或 env 解压 类型 解包命令 打包/压缩命令 tar tar xvf tar cvf gz gunzip gzip -d tar.gz tar zxvf tar zcvf zip unzip zip rar rar x rar a linux下unzip的乱码问题 unar方法 这个工具会自动检测文件的编码，也可以通过-e来指定\nsudo apt install unar unar your-zip 文件管理 文件查看\n命令 解释 ls -l 列出文件列表 ls -a 浏览隐藏文件 ls -lh 以易读方式显示大小 ls -F 列出文件和目录 ls -R 递归出子目录 ls -ltr 以修改时间排序 ls -ls 以文件大小排序 复制： cp [options] \u0026amp;lt;source file or directory\u0026amp;gt; \u0026amp;lt;target file or directory\u0026amp;gt; options选项\noptions 解释 -a 保留链接和文件 …","date":1556496000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2600,"html":"不断更新中","keywords":null,"kind":"page","lang":"en","lastmod":1556496000,"objectID":"19e9956502e641e65270a5a489e992cd","permalink":"https://bytewalking.github.io/post/2019-06-30-linux-tips/","publishdate":"2019-04-29T00:00:00Z","readingtime":6,"relpermalink":"/post/2019-06-30-linux-tips/","section":"post","tags":["Tips","Linux"],"title":"Linux 常用命令","type":"post","url":"/post/2019-06-30-linux-tips/","weight":0,"wordcount":2539},{"author":null,"categories":["Tips"],"content":"Shell变量 定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：\nyour_name=\u0026amp;quot;runoob.com\u0026amp;quot; 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：\n命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 有效的 Shell 变量名示例如下：\nRUNOOB LD_LIBRARY_PATH _var var2 无效的变量命名：\n?var=123 user*name=runoob 除了显式地直接赋值，还可以用语句给变量赋值，如：\nfor file in `ls /etc` 或\nfor file in $(ls /etc) 以上语句将 /etc 下目录的文件名循环出来。\n使用变量 使用一个定义过的变量，只要在变量名前面加美元符号即可，如：\nyour_name=\u0026amp;quot;qinjx\u0026amp;quot; echo $your_name echo ${your_name} 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：\nfor skill in Ada Coffe Action Java; do echo \u0026amp;quot;I am good at ${skill}Script\u0026amp;quot; done 如果不给skill变量加花括号，写成echo \u0026amp;ldquo;I am good at $skillScript\u0026amp;rdquo;，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。\n推荐给所有变量加上花括号，这是个好的编程习惯。\n已定义的变量，可以被重新定义，如：\nyour_name=\u0026amp;quot;tom\u0026amp;quot; echo $your_name your_name=\u0026amp;quot;alibaba\u0026amp;quot; echo $your_name 这样写是合法的，但注意，第二次赋值的时候不能写$your_name=\u0026amp;ldquo;alibaba\u0026amp;rdquo;，使用变量的时候才加美元符（$）。\n只读变量 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 …","date":1556496000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":10200,"html":"也可以作为shell语法快速入门指南","keywords":null,"kind":"page","lang":"en","lastmod":1556496000,"objectID":"3adba20376a4e0db33e5f00fc6b480c1","permalink":"https://bytewalking.github.io/post/2019-06-30-shell-tips/","publishdate":"2019-04-29T00:00:00Z","readingtime":21,"relpermalink":"/post/2019-06-30-shell-tips/","section":"post","tags":["Tips","Shell"],"title":"Shell指令速查","type":"post","url":"/post/2019-06-30-shell-tips/","weight":0,"wordcount":10148},{"author":null,"categories":["Tips"],"content":"Vim按键说明 命令模式：\ni 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 移动光标的方法 命令 解释 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) n n 为数字。光标向下移动 n 行(常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) 搜索替换 命令 解释 /word 向光标之下寻找一个名称为 word 的字符串 (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串 n 这个 n 是英文按键。代表重复前一个搜寻的动作 N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作 删除、复制与贴上 命令 解释 x, X 在一行字当中，x 为向后删除一个字符， X 为向前删除一个字符(常用) nx n 为数字，连续向后删除 n 个字符 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) yy 复制游标所在的那一行(常用) p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ (常用) u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) . 重复前一个动作的意思 (常用) ","date":1556496000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":700,"html":"主要为vim快捷键","keywords":null,"kind":"page","lang":"en","lastmod":1556496000,"objectID":"7adc29e1ce4222a6c2ceb55d3e6c45e5","permalink":"https://bytewalking.github.io/post/2019-06-30-new-vim-tips/","publishdate":"2019-04-29T00:00:00Z","readingtime":2,"relpermalink":"/post/2019-06-30-new-vim-tips/","section":"post","tags":["Tips","Vim"],"title":"Vim 常用命令","type":"post","url":"/post/2019-06-30-new-vim-tips/","weight":0,"wordcount":616},{"author":null,"categories":["Life"],"content":"最近一段时间，我经常失眠，心里总有一种焦虑感，有时候甚至会觉得生活失控。这些困惑让我开始思考：我究竟需要做些什么，才能真正改变自己的现状。\n我一直是个喜欢“瞎折腾”的人，凡事都想自己尝试一遍，而且比较倔强——不到自己山穷水尽、黔驴技穷的时候，我几乎不会去请教别人。这个性格缺点让我吃了不少亏。\n从离开学校到正式工作，这段时间如白驹过隙，恍惚间已经过去半年多了。回头看，我想记录一下这段心路历程。\n大三下学期快结束时，我就离开了学校。当时我并没有明确的职业规划，只是很迫切地想要离开校园。我没有任何求职经验，也不了解招聘流程，更没有遇到一位能给我指点迷津的贵人。于是，我稀里糊涂地去了第一家创业公司实习。不到三个月后，同学给了我另一个机会，我便去了上海。现在想想，真的觉得自己太冲动了——如果当时能好好准备校招，复习三年的知识，稳住基础，也许能进一家更大的平台，职业发展会更顺利。\n拿到上海那家公司的offer时，我非常开心——毕竟大三就能拿到过万的月薪，实在令人兴奋。回头看，我真想扇自己一巴掌：不要被蝇头小利熏了头脑。\n我的第一份工作是负责对谷歌开源项目 AppInventor 进行二次开发。这个项目让我几乎失去了对 Java 的耐心。项目使用 GWT 框架和 GAE 部署环境，但这些都是谷歌自家的产品，而我身在国内，这些技术几乎没人使用。我只能硬着头皮阅读 AppInventor 源码，遇到问题就去谷歌或翻 StackOverflow。后来，我将后端渲染的项目拆分成前后端分离，把一部分工作交给前端，情况才稍微好一些。\n后来，我有了转组机会，开始用 Python 和 Django 搭建网站后端，并差不多把 Django 框架都梳理了一遍。\n然而，公司开发组也经历了较大的人事变动：没有 Senior 指导，组内任务分配不均；前端突然离职，整体进度被拖慢。好处是，由于缺少前端，很多任务无法推进，我反而有大量空闲时间去做其他事情，比如写博客。这段插曲对我个人影响不大，但打乱了我的求职节奏——原本计划做完项目再跳槽，但现在需要重新考虑。错过了去年的校招机会，如今投社招，又失去了应届生的优势，这确实让我吃亏不少。\n为了在编程的道路上走得更长远，我需要继续打好基本功，拓展思维，积累经验。感谢在这条路上给予我帮助和认可的人，我还有很多地方需要学习，我会继续努力。\n最后，希望自己能坚持初心，继 …","date":1556150400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1100,"html":"谢谢路途中给我提供过帮助的人，感谢你们对我的认可，我还有很多地方需要向你们学习，我会继续努力的","keywords":null,"kind":"page","lang":"en","lastmod":1556150400,"objectID":"07e2dd8904c9dfe0705451c754a3d6a6","permalink":"https://bytewalking.github.io/post/2019-5-5-recent-sentiment/","publishdate":"2019-04-25T00:00:00Z","readingtime":3,"relpermalink":"/post/2019-5-5-recent-sentiment/","section":"post","tags":["think-deeply"],"title":"Recent Sentiment","type":"post","url":"/post/2019-5-5-recent-sentiment/","weight":0,"wordcount":1083},{"author":null,"categories":null,"content":"Clean White Theme for Hugo CleanWhite is a clean, elegant, but fully functional blog theme for Hugo. Here is a live demo site using this theme.\nIt is based on huxblog Jekyll Theme and Clean Blog Jekyll Theme.\nThese two upstream projects have done awesome jobs to create a blog theme, what I\u0026amp;rsquo;m doing here is porting it to Hugo, of which I like the simplicity and the much faster compiling speed. Some other features which I think could be useful, such as site search with algolia and proxy for Disqus access in China, have also been built in the CleanWhite theme. Other fancy features of upstream projects are not supported by this Hugo theme, I\u0026amp;rsquo;d like to make it as simple as possible and only focus on blog purpose, at least for now. While I created this theme, I followed the Hugo theme best practice and tried to make every part of the template as a replaceable partial html, so it could be much easier for you to make your customization based on it.\nScreenshots Home Post Search …","date":1546992000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1546992000,"objectID":"2f05902e7435de187bb5303fb74f55e2","permalink":"https://bytewalking.github.io/post/readme/","publishdate":"2019-01-09T00:00:00Z","readingtime":3,"relpermalink":"/post/readme/","section":"post","tags":null,"title":"Clean White Theme for Hugo","type":"post","url":"/post/readme/","weight":0,"wordcount":1083},{"author":null,"categories":null,"content":" “Yeah It\u0026amp;rsquo;s on. ”\nHello World! 如果你发现了这个页面\n很感谢你，愿意投入时间探索我的博客\n说明你和我有共同的兴趣\n让我们继续用爱写代码，写到世界充满爱\n","date":1541289600,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":1541289600,"objectID":"cf37d97d83d29e7c3f79c50c928a7a4d","permalink":"https://bytewalking.github.io/2017/11/03/hello-world/","publishdate":"2018-11-04T00:00:00Z","readingtime":1,"relpermalink":"/2017/11/03/hello-world/","section":"post","tags":null,"title":"Welcome to ZhaoPengHui Blog","type":"post","url":"/2017/11/03/hello-world/","weight":0,"wordcount":66},{"author":null,"categories":["Tips"],"content":"Generate SSH Key Pair ssh-keygen -C \u0026amp;#34;zhaohuabing@gmail.com\u0026amp;#34; Shadowsocks Install shadowsokcs\nsudo apt-get install python3-pip sudo pip3 install shadowsocks Create config at config/shadowsocks.json, with the following content:\n{ \u0026amp;#34;server\u0026amp;#34;:\u0026amp;#34;remote-shadowsocks-server-ip-addr\u0026amp;#34;, \u0026amp;#34;server_port\u0026amp;#34;:443, \u0026amp;#34;local_address\u0026amp;#34;:\u0026amp;#34;127.0.0.1\u0026amp;#34;, \u0026amp;#34;local_port\u0026amp;#34;:1080, \u0026amp;#34;password\u0026amp;#34;:\u0026amp;#34;your-passwd\u0026amp;#34;, \u0026amp;#34;timeout\u0026amp;#34;:300, \u0026amp;#34;method\u0026amp;#34;:\u0026amp;#34;aes-256-cfb\u0026amp;#34;, \u0026amp;#34;fast_open\u0026amp;#34;:false, \u0026amp;#34;workers\u0026amp;#34;:1 } Start a local socks proxy\nsudo sslocal -c config/shadowsocks.json -d start In case there is an openssl error, modify shadowsocks source file.\nsudo vi /usr/local/lib/python3.6/dist-packages/shadowsocks/crypto/openssl.py :%s/cleanup/reset/gc Convert shadowsocks socks proxy to http proxy\nsudo apt-get install polipo echo \u0026amp;#34;socksParentProxy = localhost:1080\u0026amp;#34; | sudo tee -a /etc/polipo/config sudo service polipo restart Http proxy now is …","date":1527120000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":200,"html":"Everything about setting up my own ubuntu desktop, it's just a Note in case I need it later","keywords":null,"kind":"page","lang":"en","lastmod":1527120000,"objectID":"acef740336515250f115284b46f1f096","permalink":"https://bytewalking.github.io/2018/05/24/set_up_my_ubuntu_desktop/","publishdate":"2018-05-24T00:00:00Z","readingtime":1,"relpermalink":"/2018/05/24/set_up_my_ubuntu_desktop/","section":"post","tags":["ubuntu"],"title":"Everything about Setting Up My Ubuntu Desktop","type":"post","url":"/2018/05/24/set_up_my_ubuntu_desktop/","weight":0,"wordcount":121},{"author":null,"categories":["Tech"],"content":"外部系统访问控制 除用户访问和微服务之间的相互访问外，外部的第三方系统也可能需要访问系统内部的微服务。例如在上一篇博客的网上商店例子中，外部的推荐服务可能需要接入系统，以获取商店的商品目录信息。相对于内部服务之间的访问而言，外部系统的访问需要进行严格的安全控制。\n使用账号进行控制 可以为外部系统创建一个用户账号，类似普通用户一样对外部系统的账号进行管理，并使用该账号对外部系统进行认证和权限控制。\n采用这种方式的问题是难以处理用户相关的敏感数据。因为外部系统自身也是微服务系统中的一个用户账号，因此该外部系统只能访问该账号自身的数据和一些不敏感的公共数据，而不能访问和用户相关的数据。例如在网上商店的例子中，外部系统可以采用该方式访问商品目录信息，但不应允许访问用户历史购买记录，用户余额等信息。\nAPI Token 是一个API Token（又称API Key）可以控制对用户敏感数据的访问。微服务应用提供一个API Token的生成界面，用户登录后可以生成自己的API Token，并在第三方应用使用该API Token访问微服务的API。在这种情况下，一般只允许第三方应用访问该Token所属用户自身的数据，而不能访问其他用户的敏感私有数据。\n例如Github就提供了Personal API Token功能，用户可以在Github的开发者设置界面中创建Token，然后使用该Token来访问Github的API。在创建Token时，可以设置该Token可以访问用户的哪些数据，如查看Repo信息，删除Repo，查看用户信息，更新用户信息等。\n使用API Token来访问Github API\ncurl -u zhaohuabing:fbdf8e8862252ed0f3ba9dba4e328c01ac93aeec https://api.github.com/user 不用试了,这不是我的真实API Token, just for demonstration :-)\n使用API Token而不是直接使用用户名/密码来访问API的好处是降低了用户密码暴露的风险，并且可以随时收回Token的权限而不用修改密码。\n由于API Token只能访问指定用户的数据，因此适合于用户自己开发一些脚本或小程序对应用中自己的数据进行操作。\nOAuth 某些第三方应用需要访问不同用户的数据，或者对多个用 …","date":1527098400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2300,"html":"一些外部的第三方系统可能需要访问系统内部的微服务。例如在网上商店的例子中，外部的推荐服务可能需要接入系统，以获取商店的商品目录信息。相对于内部服务之间的访问而言，外部系统的访问需要进行严格的安全控制。","keywords":null,"kind":"page","lang":"en","lastmod":1527098400,"objectID":"bcf92db93ffdd43ba91e4322cf6c6ece","permalink":"https://bytewalking.github.io/2018/05/23/external_system_auth/","publishdate":"2018-05-23T18:00:00Z","readingtime":5,"relpermalink":"/2018/05/23/external_system_auth/","section":"post","tags":["Microservice","Security"],"title":"微服务安全沉思录之三","type":"post","url":"/2018/05/23/external_system_auth/","weight":0,"wordcount":2279},{"author":null,"categories":["Tech"],"content":"服务间认证与鉴权 除来自用户的访问请求以外，微服务应用中的各个微服务相互之间还有大量的访问，包括下述场景：\n用户间接触发的微服务之间的相互访问 例如在一个网上商店应用中，用户访问购物车微服务进行结算时，购物车微服务可能需要访问用户评级微服务获取用户的会员级别，以得到用户可以享受购物折扣。 非用户触发的微服务之间的相互访问 例如数据同步或者后台定时任务导致的微服务之间的相互访问。 根据应用系统的数据敏感程度的不同，对于系统内微服务的相互访问可能有不同的安全要求。\n对微服务之间的相互访问不进行安全控制 在某些场景下，可以假设同一应用中微服务之间的相互访问都是可信的。在这种情况下，应用依赖于内部网络的防火墙及其他网络安全措施来保证安全性。在这种情况对入侵者攻击进入内部网络后没有保护措施。入侵者可以对微服务间的通信进行典型的中间人攻击，例如窃听通信内容，伪造和修改通信数据，甚至假装为一个合法的微服务进行通信。\n采用Service Account(服务账号)进行安全控制 “内部网络中微服务之间的所有通信都是可信的”这个假设在某些场景下是不成立的，特别是在微服务中保存有用户信息这种非常重要的数据的情况下。将敏感信息直接暴露在内部攻击下的做法是非常危险的。 解决该问题的一种方案是使用服务账号来对微服务之间的相互访问进行控制。\n用户权限控制的一个普遍方法是使用”用户账号（User Account）”来标识一个系统用户，并对其进行身份认证和操作鉴权。类似地，可以为系统中每一个服务也创建一个账号，称为”服务账号(Service Accout)“。 该服务账号表示了微服务的身份，以用于控制该微服务对系统中其它微服务的访问权限，如可以对哪些微服务的哪些资源进行何种操作。当一个微服务访问另一个微服务时，被访问的微服务需要验证访问者的服务账号，以确定其身份和资源操作权限。\nSPIFEE标准 Secure Production Identity Framework For Everyone (SPIFFE)是一套服务之间相互进行身份识别的标准，主要包含以下内容：\nSPIFFE ID标准，SPIFFE ID是服务的唯一标识，实现为统一资源标识\u0026amp;quot;Uniform Resource Identifier (URI)”符。 SVID(SPIFFE Verifiable Identity …","date":1527087600,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":2000,"html":"除来自用户的访问请求以外，微服务应用中的各个微服务相互之间还有大量的访问,根据应用系统数据敏感程度不同，对于系统内微服务的访问也需要进行相应的安全控制。","keywords":null,"kind":"page","lang":"en","lastmod":1527087600,"objectID":"d7d93ee7d2a2b13ec20c157389fd7a3a","permalink":"https://bytewalking.github.io/2018/05/23/service_2_service_auth/","publishdate":"2018-05-23T15:00:00Z","readingtime":4,"relpermalink":"/2018/05/23/service_2_service_auth/","section":"post","tags":["Microservice","Security"],"title":"微服务安全沉思录之二","type":"post","url":"/2018/05/23/service_2_service_auth/","weight":0,"wordcount":1935},{"author":null,"categories":["Tech"],"content":" 这段时间对之前微服务安全相关的一些想法进行了进一步总结和归纳，理清了在之前文章里面没有想得太清楚的地方，例如服务间的认证与鉴权以及用户身份在服务调用链中的传递。\n在这一系列文章里，我将尝试分为三个部分对微服务安全进行系统阐述：用户访问认证与鉴权，服务间认证与鉴权，外部系统访问控制。\n目录 {:.no_toc}\n目录 {:toc} 前言 微服务架构的引入为软件应用带来了诸多好处：包括小开发团队，缩短开发周期，语言选择灵活性，增强服务伸缩能力等。与此同时，也引入了分布式系统的诸多复杂问题。其中一个挑战就是如何在微服务架构中实现一个灵活，安全，高效的认证和鉴权方案。\n相对于传统单体应用，微服务架构下的认证和鉴权涉及到场景更为复杂，涉及到用户访问微服务应用，第三方应用访问微服务应用，应用内多个微服务之间相互访问等多种场景，每种场景下的认证和鉴权方案都需要考虑到，以保证应用程序的安全性。本系列博文将就此问题进行一次比较完整的探讨。 微服务认证和鉴权涉及到的三种场景 用户认证和鉴权 用户身份认证 一个完整的微服务应用是由多个相互独立的微服务进程组成的，对每个微服务的访问都需要进行用户认证。如果将用户认证的工作放到每个微服务中，存在下面一些问题：\n需要在各个微服务中重复实现这部分公共逻辑。虽然我们可以使用代码库复用部分代码，但这又会导致所有微服务对特定代码库及其版本存在依赖，影响微服务语言/框架选择的灵活性。 将认证和鉴权的公共逻辑放到微服务实现中违背了单一职责原理，开发人员应重点关注微服务自身的业务逻辑。 用户需要分别登录以访问系统中不同的服务。 由于在微服务架构中以API Gateway作为对外提供服务的入口，因此可以在API Gateway处提供统一的用户认证，用户只需要登录一次，就可以访问系统中所有微服务提供的服务。\n用户状态保持 HTTP是一个无状态的协议，对服务器来说，用户的每次HTTP请求是相互独立的。互联网是一个巨大的分布式系统，HTTP协议作为互联网上的一个重要协议，在设计之初要考虑到大量应用访问的效率问题。无状态意味着服务端可以把客户端的请求根据需要发送到集群中的任何一个节点，HTTP的无状态设计对负载均衡有明显的好处，由于没有状态，用户请求可以被分发到任意一个服务器，应用也可以在靠近用户的网络边缘部署缓存服务器。对于不需要身份认证的服务，例如浏览新闻网页等 …","date":1527069600,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":3100,"html":"这段时间对之前微服务安全相关的一些想法进行了进一步总结和归纳，理清在之前文章里面没有想得太清楚的地方，例如服务间的认证与鉴权以及用户身份在服务调用链中的传递。在这一系列博客里面将分为三个部分对微服务安全进行系统阐述：用户访问认证与鉴权，服务间认证与鉴权，外部系统访问控制。","keywords":null,"kind":"page","lang":"en","lastmod":1527069600,"objectID":"3fc17cbcf909103e423326182d72a807","permalink":"https://bytewalking.github.io/2018/05/22/user_authentication_authorization/","publishdate":"2018-05-23T10:00:00Z","readingtime":7,"relpermalink":"/2018/05/22/user_authentication_authorization/","section":"post","tags":["Microservice","Security"],"title":"微服务安全沉思录之一","type":"post","url":"/2018/05/22/user_authentication_authorization/","weight":0,"wordcount":3093},{"author":null,"categories":["Tech"],"content":"前言 Kubernets 1.9版本引入了Admission Webhook(web 回调)扩展机制，通过Webhook,开发者可以非常灵活地对Kubernets API Server的功能进行扩展，在API Server创建资源时对资源进行验证或者修改。\n使用webhook的优势是不需要对API Server的源码进行修改和重新编译就可以扩展其功能。插入的逻辑实现为一个独立的web进程，通过参数方式传入到kubernets中，由kubernets在进行自身逻辑处理时对扩展逻辑进行回调。\nIstio 0.7版本就利用了Kubernets webhook实现了sidecar的自动注入。\n什么是Admission Admission是Kubernets中的一个术语，指的是Kubernets API Server资源请求过程中的一个阶段。如下图所示，在API Server接收到资源创建请求时，首先会对请求进行认证和鉴权，然后经过Admission处理，最后再保存到etcd。 从图中看到，Admission中有两个重要的阶段，Mutation和Validation，这两个阶段中执行的逻辑如下：\nMutation\nMutation是英文“突变”的意思,从字面上可以知道在Mutation阶段可以对请求内容进行修改。\nValidation\n在Validation阶段不允许修改请求内容，但可以根据请求的内容判断是继续执行该请求还是拒绝该请求。\nAdmission webhook 通过Admission webhook,可以加入Mutation和Validation两种类型的webhook插件，这些插件和Kubernets提供的预编译的Admission插件具有相同的能力。可以想到的用途包括：\n修改资源。例如Istio就通过Admin Webhook在Pod资源中增加了Envoy sidecar容器。 自定义校验逻辑，例如对资源名称有一些特殊要求。或者对自定义资源的合法性进行校验。 采用Webhook自动注入Istio Sidecar Kubernets版本要求 webhook支持需要Kubernets1.9或者更高的版本,使用下面的命令确认kube-apiserver的Admin webhook功能已启用。\nkubectl api-versions | grep …","date":1527033600,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":1200,"html":"Kubernets 1.9版本引入了Admission Webhook(web 回调)扩展机制，通过Webhook,开发者可以非常灵活地对Kubernets API Server的功能进行扩展，在API Server创建资源时对资源进行验证或者修改。 Istio 0.7版本就利用了Kubernets webhook实现了sidecar的自动注入。","keywords":null,"kind":"page","lang":"en","lastmod":1527033600,"objectID":"61cbee2b7380aaa6e9b9f882840da6a0","permalink":"https://bytewalking.github.io/2018/05/23/istio-auto-injection-with-webhook/","publishdate":"2018-05-23T00:00:00Z","readingtime":3,"relpermalink":"/2018/05/23/istio-auto-injection-with-webhook/","section":"post","tags":["Kubernetes","Istio"],"title":"Istio Sidecar自动注入原理","type":"post","url":"/2018/05/23/istio-auto-injection-with-webhook/","weight":0,"wordcount":1133},{"author":null,"categories":["Tech"],"content":"微服务架构的演进 作为一种架构模式，微服务将复杂系统切分为数十乃至上百个小服务，每个服务负责实现一个独立的业务逻辑。这些小服务易于被小型的软件工程师团队所理解和修改，并带来了语言和框架选择灵活性，缩短应用开发上线时间，可根据不同的工作负载和资源要求对服务进行独立缩扩容等优势。\n另一方面，当应用被拆分为多个微服务进程后，进程内的方法调用变成了了进程间的远程调用。引入了对大量服务的连接、管理和监控的复杂性。\n该变化带来了分布式系统的一系列问题，例如：\n如何找到服务的提供方？ 如何保证远程方法调用的可靠性？ 如何保证服务调用的安全性？ 如何降低服务调用的延迟？ 如何进行端到端的调试？ 另外生产部署中的微服务实例也增加了运维的难度,例如：\n如何收集大量微服务的性能指标已进行分析？ 如何在不影响上线业务的情况下对微服务进行升级？ 如何测试一个微服务集群部署的容错和稳定性？ 这些问题涉及到成百上千个服务的通信、管理、部署、版本、安全、故障转移、策略执行、遥测和监控等，要解决这些微服务架构引入的问题并非易事。\n让我们来回顾一下微服务架构的发展过程。在出现服务网格之前，我们最开始在微服务应用程序内理服务之间的通讯逻辑，包括服务发现，熔断，重试，超时，加密，限流等逻辑。 在一个分布式系统中，这部分逻辑比较复杂，为了为微服务应用提供一个稳定、可靠的基础设施层，避免大家重复造轮子，并减少犯错的可能，一般会通过对这部分负责服务通讯的逻辑进行抽象和归纳，形成一个代码库供各个微服务应用程序使用，如下图所示： 公共的代码库减少了应用程序的开发和维护工作量，降低了由应用开发人员单独实现微服务通讯逻辑出现错误的机率，但还是存在下述问题：\n微服务通讯逻辑对应用开发人员并不透明，应用开发人员需要理解并正确使用代码\t库，不能将其全部精力聚焦于业务逻辑。 需要针对不同的语言/框架开发不同的代码库，反过来会影响微服务应用开发语言\t和框架的选择，影响技术选择的灵活性。 随着时间的变化，代码库会存在不同的版本，不同版本代码库的兼容性和大量运行\t环境中微服务的升级将成为一个难题。 可以将微服务之间的通讯基础设施层和TCP/IP协议栈进行类比。TCP/IP协议栈为操作系统中的所有应用提供基础通信服务，但TCP/IP协议栈和应用程序之间并没有紧密的耦合关系，应用只需要使用TCP/IP协议提供的底层通讯功能,并不关心 …","date":1522324800,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":8500,"html":"作为一种架构模式，微服务将复杂系统切分为数十乃至上百个小服务，每个服务负责实现一个独立的业务逻辑。这些小服务易于被小型的软件工程师团队所理解和修改，并带来了语言和框架选择灵活性，缩短应用开发上线时间，可根据不同的工作负载和资源要求对服务进行独立缩扩容等优势。另一方面，当应用被拆分为多个微服务进程后，进程内的方法调用变成了了进程间的远程调用。引入了对大量服务的连接、管理和监控的复杂性,本文介绍了Service Mesh模式如何应对微服务架构的这些挑战，以及Service Mesh的明星开源项目Istio。","keywords":null,"kind":"page","lang":"en","lastmod":1522324800,"objectID":"58e1fcbb286268d60015d8695e72e3b4","permalink":"https://bytewalking.github.io/2018/03/29/what-is-service-mesh-and-istio/","publishdate":"2018-03-29T12:00:00Z","readingtime":17,"relpermalink":"/2018/03/29/what-is-service-mesh-and-istio/","section":"post","tags":["Microservice","Service Mesh","Istio"],"title":"谈谈微服务架构中的基础设施：Service Mesh与Istio","type":"post","url":"/2018/03/29/what-is-service-mesh-and-istio/","weight":0,"wordcount":8405},{"author":null,"categories":["Tips"],"content":"Ubuntu 设置docker使用http proxy sudo /etc/default/docker export http_proxy=\u0026amp;#34;http://127.0.0.1:3128/\u0026amp;#34; export https_proxy=\u0026amp;#34;http://127.0.0.1:3128/\u0026amp;#34; export HTTP_PROXY=\u0026amp;#34;http://127.0.0.1:3128/\u0026amp;#34; export HTTPS_PROXY=\u0026amp;#34;http://127.0.0.1:3128/\u0026amp;#34; 加载配置并重启docker sudo service docker restart CentOS 设置docker使用http proxy sudo mkdir -p /etc/systemd/system/docker.service.d echo \u0026amp;#39; [Service] Environment=\u0026amp;#34;HTTP_PROXY=http://proxy.foo.bar.com:80/\u0026amp;#34; \u0026amp;#39; | sudo tee /etc/systemd/system/docker.service.d/http-proxy.conf 加载配置并重启docker sudo systemctl daemon-reload sudo systemctl restart docker ","date":1520964000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":100,"html":"如何配置docker使用HTTP代理","keywords":null,"kind":"page","lang":"en","lastmod":1520964000,"objectID":"98b8057999561a04d562f017fde4df05","permalink":"https://bytewalking.github.io/2018/03/13/use-docker-behind-http-proxy/","publishdate":"2018-03-13T18:00:00Z","readingtime":1,"relpermalink":"/2018/03/13/use-docker-behind-http-proxy/","section":"post","tags":["Tips","Docker"],"title":"如何配置docker使用HTTP代理","type":"post","url":"/2018/03/13/use-docker-behind-http-proxy/","weight":0,"wordcount":92},{"author":null,"categories":["Tips"],"content":"vim graphical cheat sheet Vim Jumps ^ — Move to start of line $ — Move to end of line b — Move back a word w — Move forward a word e — Move to the end of the next word Ctrl-o and Ctrl-i to go to the previous/next location you jumped to (two backticks) jump back to where you were gi go back to the last place you inserted a text and enter insert mode Vim Navigations { and } jump paragraph back and forth Ctrl-F/B move one screen back and forth Search the word under cursor, then n/p to jump to next/previous Enable Vim mode in bash vi ~/.inputrc set editing-mode vi\nEnable system clipboard upport See if system clipboard is supported:\n$ vim --version | grep clipboard -clipboard +iconv +path_extra -toolbar +eval +mouse_dec +startuptime -xterm_clipboard Rinstall vim as vim-gnome:\nsudo apt-get install vim-gnome Select what you want using the mouse - then type to copy to clipboard:\n\u0026amp;#34;+y To paste to vim from clipboard type:\n\u0026amp;#34;+p Others Ex: open the current directory set number: show line …","date":1518174000,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":200,"html":"Vim Tips and tricks","keywords":null,"kind":"page","lang":"en","lastmod":1518174000,"objectID":"2d0e4272390337188b486ff2335caebb","permalink":"https://bytewalking.github.io/2018/02/09/vim-tips/","publishdate":"2018-02-09T11:00:00Z","readingtime":1,"relpermalink":"/2018/02/09/vim-tips/","section":"post","tags":["Tips","Vim"],"title":"Vim Tips","type":"post","url":"/2018/02/09/vim-tips/","weight":0,"wordcount":181},{"author":null,"categories":["Tips"],"content":"Add the docker group if it doesn\u0026amp;rsquo;t already exist: sudo groupadd docker\nAdd the connected user \u0026amp;ldquo;$USER\u0026amp;rdquo; to the docker group. Change the user name to match your preferred user if you do not want to use your current user: sudo gpasswd -a $USER docker\nEither do a newgrp docker or log out/in to activate the changes to groups. ","date":1518170400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":100,"html":"如何使用非root用户执行docker命令","keywords":null,"kind":"page","lang":"en","lastmod":1518170400,"objectID":"92d7e3e34329f74a5a955e31f5743bae","permalink":"https://bytewalking.github.io/2018/02/09/docker-without-sudo/","publishdate":"2018-02-09T10:00:00Z","readingtime":1,"relpermalink":"/2018/02/09/docker-without-sudo/","section":"post","tags":["Tips","Docker"],"title":"如何使用非root用户执行docker命令","type":"post","url":"/2018/02/09/docker-without-sudo/","weight":0,"wordcount":59},{"author":null,"categories":["Tech"],"content":"前言 微服务架构的引入为软件应用带来了诸多好处：包括小开发团队，缩短开发周期，语言选择灵活性，增强服务伸缩能力等。与此同时，也引入了分布式系统的诸多复杂问题。其中一个挑战就是如何在微服务架构中实现一个灵活，安全，高效的认证和鉴权方案。本文将尝试就此问题进行一次比较完整的探讨。\n单体应用的实现方式 在单体架构下，整个应用是一个进程，在应用中，一般会用一个安全模块来实现用户认证和鉴权。\n用户登录时，应用的安全模块对用户身份进行验证，验证用户身份合法后，为该用户生成一个会话(Session)，并为该Session关联一个唯一的编号(Session Id)。Session是应用中的一小块内存结构，其中保存了登录用户的信息，如User name, Role, Permission等。服务器把该Session的Session Id返回给客户端，客户端将Session Id以cookie或者URL重写的方式记录下来，并在后续请求中发送给应用，这样应用在接收到客户端访问请求时可以使用Session Id验证用户身份，不用每次请求时都输入用户名和密码进行身份验证。\n备注：为了避免Session Id被第三者截取和盗用，客户端和应用之前应使用TLS加密通信，session也会设置有过期时间。\n单体应用用户登录认证序列图 客户端访问应用时，Session Id随着HTTP请求发送到应用，客户端请求一般会通过一个拦截器处理所有收到的客户端请求。拦截器首先判断Session Id是否存在，如果该Session Id存在，就知道该用户已经登录。然后再通过查询用户权限判断用户能否执行该此请求，以实现操作鉴权。 单体应用用户操作鉴权序列图 微服务认证和鉴权面临的问题 在微服务架构下，一个应用被拆分为多个微服务进程，每个微服务实现原来单体应用中一个模块的业务功能。应用拆分后，对每个微服务的访问请求都需要进行认证和鉴权。如果参考单体应用的实现方式会遇到下述问题：\n认证和鉴权逻辑需要在每个微服务中进行处理，需要在各个微服务中重复实现这部分公共逻辑。虽然我们可以使用代码库复用部分代码，但这又会导致所有微服务对特定代码库及其版本存在依赖，影响微服务语言/框架选择的灵活性。 微服务应遵循单一职责原理，一个微服务只处理单一的业务逻辑。认证和鉴权的公共逻辑不应该放到微服务实现中。 为了充分利用微服务架构的好处，实 …","date":1517659200,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":5600,"html":"微服务架构的引入为软件应用带来了诸多好处：包括小开发团队，缩短开发周期，语言选择灵活性，增强服务伸缩能力等。与此同时，也引入了分布式系统的诸多复杂问题。其中一个挑战就是如何在微服务架构中实现一个灵活，安全，高效的认证和鉴权方案。本文将尝试就此问题进行一次比较完整的探讨。","keywords":null,"kind":"page","lang":"en","lastmod":1517659200,"objectID":"c1d32da205ea082b3dd7061c39ea7e8b","permalink":"https://bytewalking.github.io/2018/05/22/user_authentication_authorization/","publishdate":"2018-02-03T12:00:00Z","readingtime":12,"relpermalink":"/2018/05/22/user_authentication_authorization/","section":"post","tags":["Microservice","Security"],"title":"如何构建安全的微服务应用？","type":"post","url":"/2018/05/22/user_authentication_authorization/","weight":0,"wordcount":5532},{"author":null,"categories":["Tech"],"content":"前言 我们知道，kubernetes的Cluster Network属于私有网络，只能在cluster Network内部才能访问部署的应用，那如何才能将Kubernetes集群中的应用暴露到外部网络，为外部用户提供服务呢？本文探讨了从外部网络访问kubernetes cluster中应用的几种实现方式。\n本文尽量试着写得比较容易理解，但要做到“深入浅出”，把复杂的事情用通俗易懂的语言描述出来是非常需要功力的，个人自认尚未达到此境界，唯有不断努力。此外，kubernetes本身是一个比较复杂的系统，无法在本文中详细解释涉及的所有相关概念，否则就可能脱离了文章的主题，因此假设阅读此文之前读者对kubernetes的基本概念如docker，container，pod已有所了解。\n另外此文中的一些内容是自己的理解，由于个人的知识范围有限，可能有误，如果读者对文章中的内容有疑问或者勘误，欢迎大家指证。\nPod和Service 我们首先来了解一下Kubernetes中的Pod和Service的概念。\nPod(容器组),英文中Pod是豆荚的意思，从名字的含义可以看出，Pod是一组有依赖关系的容器，Pod包含的容器都会运行在同一个host节点上，共享相同的volumes和network namespace空间。Kubernetes以Pod为基本操作单元，可以同时启动多个相同的pod用于failover或者load balance。\nPod的生命周期是短暂的，Kubernetes根据应用的配置，会对Pod进行创建，销毁，根据监控指标进行缩扩容。kubernetes在创建Pod时可以选择集群中的任何一台空闲的Host，因此其网络地址是不固定的。由于Pod的这一特点，一般不建议直接通过Pod的地址去访问应用。\n为了解决访问Pod不方便直接访问的问题，Kubernetes采用了Service的概念，Service是对后端提供服务的一组Pod的抽象，Service会绑定到一个固定的虚拟IP上，该虚拟IP只在Kubernetes Cluster中可见，但其实该IP并不对应一个虚拟或者物理设备，而只是IPtable中的规则，然后再通过IPtable将服务请求路由到后端的Pod中。通过这种方式，可以确保服务消费者可以稳定地访问Pod提供的服务，而不用关心Pod的创建、删除、迁移等变化以及如何用一 …","date":1511870400,"dir":"post/","expirydate":-62135596800,"fuzzywordcount":5600,"html":"我们知道，kubernetes的Cluster Network属于私有网络，只能在cluster Network内部才能访问部署的应用，那如何才能将Kubernetes集群中的应用暴露到外部网络，为外部用户提供服务呢？本文探讨了从外部网络访问kubernetes cluster中应用的几种实现方式。","keywords":null,"kind":"page","lang":"en","lastmod":1511870400,"objectID":"62314fd01037305fcf6b8c9ad3b3b02d","permalink":"https://bytewalking.github.io/2017/11/28/access-application-from-outside/","publishdate":"2017-11-28T12:00:00Z","readingtime":12,"relpermalink":"/2017/11/28/access-application-from-outside/","section":"post","tags":["Kubernetes"],"title":"如何从外部访问Kubernetes集群中的应用？","type":"post","url":"/2017/11/28/access-application-from-outside/","weight":0,"wordcount":5543},{"author":null,"categories":null,"content":"About Me Hi, I’m Evan — a software engineer, a gamer, a wanderer between cities, and someone still learning how to live with clarity.\nI build systems, chase down bugs, shape architectures, and currently work in the world of Web3 gaming.\nMy work keeps my logic sharp, but life stretches far beyond logic alone.\nI love the immersion of AAA games and the quiet company of cats.\nI enjoy late-night drives, and the way a good book or film can open a hidden door in the mind.\nPhotography is my newest obsession — with a Fuji XT5 in hand, I try to capture the balance between motion and stillness in the city,\nthose fleeting pockets of order in an otherwise restless world.\nIn the past few years, I’ve walked through long relationships, breakups, attempts at repair, and the eventual release.\nI’ve dealt with team reshuffles, technical rebuilds, and career doubts.\nNone of these moments were glamorous, but they shaped me in ways I couldn’t ignore.\nNow I’m learning languages, psychology, design — slowly …","date":-62135596800,"dir":"about/","expirydate":-62135596800,"fuzzywordcount":300,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://bytewalking.github.io/about/","publishdate":"0001-01-01T00:00:00Z","readingtime":2,"relpermalink":"/about/","section":"","tags":null,"title":"","type":"page","url":"/about/","weight":0,"wordcount":265},{"author":null,"categories":null,"content":"Go 语言学习笔记 Envoy 学习笔记 ","date":-62135596800,"dir":"notes/","expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"1ede8046f9c3a02d422dea7bbf324e64","permalink":"https://bytewalking.github.io/notes/","publishdate":"0001-01-01T00:00:00Z","readingtime":1,"relpermalink":"/notes/","section":"","tags":null,"title":"","type":"page","url":"/notes/","weight":0,"wordcount":12},{"author":null,"categories":null,"content":"","date":-62135596800,"dir":"search/","expirydate":-62135596800,"fuzzywordcount":100,"html":null,"keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8946788897930c0c0c39fbfcd30ff2e4","permalink":"https://bytewalking.github.io/search/placeholder/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/search/placeholder/","section":"search","tags":null,"title":"","type":"search","url":"/search/placeholder/","weight":0,"wordcount":0},{"author":null,"categories":null,"content":"","date":-62135596800,"dir":"archive/","expirydate":-62135596800,"fuzzywordcount":100,"html":"Archive of historical posts.","keywords":null,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"a06e5ce9eca4c3260843078104889780","permalink":"https://bytewalking.github.io/archive/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/archive/","section":"","tags":null,"title":"Posts Archive","type":"archive","url":"/archive/","weight":0,"wordcount":0}]